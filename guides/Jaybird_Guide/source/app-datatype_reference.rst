.. raw:: latex

  \appendix

  \titleformat{\section}
  {\huge\color{red}}
  {\thesection}{1em}{}

  \renewcommand{\thetable}{\Asbuk{application}.\arabic{table}} % нумерация таблиц с номером section

  \renewcommand{\thefigure}{\Asbuk{application}.\arabic{figure}}

  \renewcommand{\thesubsection}{\Asbuk{application}.\arabic{subsection}} % нумерация подразделов типа F.1

  \renewcommand{\theredlisting}{\Asbuk{application}.\arabic{redlisting}}

  \appcount

Типы данных
====================

.. note::

    В разделе описаны нестандартные типы данных, поддерживаемые ``Jaybird``, поведение, отклоняющееся от стандарта  ``JDBC``, 
    или недавно появившиеся функции. Он не содержит полной документации по всем поддерживаемым типам данных.

Бинарные типы BINARY/VARBINARY
---------------------------------

Типы ``JDBC`` (и стандарта ``SQL``) ``BINARY`` и ``VARBINARY`` в ``Firebird`` называются ``CHAR(n) CHARACTER SET OCTETS`` и ``VARCHAR(n) CHARACTER SET OCTETS``.

В ``Firebird 4.0`` появились имена ``BINARY`` и ``VARBINARY/BINARY VARYING`` как псевдонимы для ``(VAR)CHAR(n) CHARACTER SET OCTETS``.

В ``Java`` для работы с ``binary`` и ``varbinary`` обычно используются массивы байтов и ``InputStream/OutputStream``.

Обработка BINARY/VARBINARY
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``Jaybird`` всегда интерпретирует ``(VAR)CHAR(n) CHARACTER SET OCTETS`` как ``JDBC`` типы ``BINARY/VARBINARY``.

``Jaybird`` будет передавать информацию о типе JDBC BINARY/VARBINARY во все метаданные 
(``DatabaseMetaData``, ``ResultSetMetaData``, ``ParameterMetaData``) для столбцов и параметров типа ``(VAR)CHAR(n) CHARACTER SET OCTETS``, 
а ``getObject(int/String)`` всегда будет возвращать ``byte[]``.

Методы ``get`` (для результирующего набора/вызываемого оператора), ``set-методы`` (подготовленный/вызываемый оператор) 
и обновления (результирующий набор) для столбцов этого типа ограничены:

* ``get/set/updateNull``
* ``get/set/updateBytes``
* ``get/set/updateBinaryStream``
* ``get/set/updateAsciiStream``
* ``get/set/updateString (с использованием кодировки по умолчанию или кодировки соединения)``
* ``get/set/updateCharacterStream (с использованием кодировки по умолчанию или кодировки соединения)``
* ``get/set/updateObject (with String, byte[], InputStream, Reader)``
* ``get/setObject with a java.sql.RowId``
* ``get/setRowId``

Другие методы ``get/set/update`` или типы объектов, поддерживаемые для "обычных" полей ``(VAR)CHAR``, недоступны.

Тип BOOLEAN
----------------

В ``Firebird 3.0`` появился тип ``BOOLEAN``.

Поддержка BOOLEAN
~~~~~~~~~~~~~~~~~~~~~~~

С параметрами типа ``BOOLEAN`` ``Jaybird`` поддерживает большинство других типов ``Java``, используя следующее соответствие:

.. tabularcolumns:: |>{\ttfamily\arraybackslash}\X{4}{16}|>{\ttfamily\arraybackslash}\X{6}{16}|>{\ttfamily\arraybackslash}\X{6}{16}|
.. list-table:: Соответветствие типов данных
   :class: longtable
   :header-rows: 1

   * - Тип
     - Метод set
     - Метод get
   * - String
     - "true"/"Y"/"T"/"1" устанавливает true, все остальное - false
     - true это "true", false это "false"
   * - integer types
     - 0 устанавливает false, все остальное - true
     - true это 1, false это 0
   * - float
     - Точное значение 0.0f устанавливает false, все остальное - true
     - true это 1.0f, false это 0.0f
   * - double
     - Точное 0.0 устанавливает false, все остальное - true
     - true это 1.0, false это 0.0
   * - BigDecimal
     - 0 (ZERO) (с помощью compareTo) устанавливает false, все остальное - true
     - true это 1 (ONE), false это 0 (ZERO)

Рекомендуется избегать опций ``float``, ``double`` и ``BigDecimal``.

Работа с логическими типами
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``Firebird 2.5`` и более ранние версии не поддерживают ``BOOLEAN``, но поддержка булевых чисел может быть имитирована.

Рекомендуется использовать следующие варианты:

* Использовать ``SMALLINT`` со значениями 0 и 1
* Использовать ``CHAR(1)`` (или ``VARCHAR(1)``) со значениями ``'Y'`` и ``'N'``
* Использовать ``CHAR`` или ``VARCHAR`` длиной 5 или больше со значениями ``'true'`` и ``'false'``.

Рекомендуется создать домен для "имитированных" логических значений с проверочным ограничением, чтобы ограничить возможные значения.
При этом не следует использовать в имени домена ``BOOLEAN``, чтобы избежать проблем при обновлении до ``Firebird 3.0``.

Для небулевых типов ``Jaybird`` поддерживает следующие преобразования с помощью ``setBoolean`` и ``getBoolean``:

.. tabularcolumns:: |>{\ttfamily\arraybackslash}\X{5}{17}|>{\ttfamily\arraybackslash}\X{6}{17}|>{\ttfamily\arraybackslash}\X{6}{17}|
.. list-table:: Преобразование с помощью setBoolean и getBoolean
   :class: longtable
   :header-rows: 1

   * - Тип
     - setBoolean
     - getBoolean
   * - (VAR)CHAR(<5)
     - 'Y'/'T'/'1'/'true' - это true (без учета регистра), все остальное - false
     - true устанавливает 'Y', false устанавливает 'N'
   * - (VAR)CHAR(>=5)
     - 'Y'/'T'/'1'/'true' - это true (без учета регистра), все остальное - false
     - true устанавливает 'true', false устанавливает 'false'
   * - BLOB SUB_TYPE TEXT
     - 'Y'/'T'/'1'/'true' - это true (без учета регистра), все остальное - false
     - true устанавливает 'true', false устанавливает 'false'
   * - SMALLINT/INTEGER/BIGINT
     - 1 - это true, все остальное - false
     - true устанавливает 1, false устанавливает 0
   * - DECIMAL/NUMERIC
     - Обрезанное целое значение 1 - true, все остальное - false
     - true устанавливает 1, false устанавливает 0
   * - REAL/FLOAT
     - Точное значение 1.0f - true, все остальное - false
     - true устанавливает 1.0f, false устанавливает 0.0f
   * - DOUBLE PRECISION
     - Точное значение 1.0 - true, все остальное - false
     - true задает 1.0, false - 0.0
   * - DECFLOAT
     - Точное значение 1E0 - true, все остальное - false (включая 1.0E0!).
     - true устанавливает 1E0, false устанавливает 0E0

Рекомендуется избегать опций ``DECIMAL``, ``NUMERIC``, ``REAL/FLOAT``, ``DOUBLE PRECISION`` и ``DECFLOAT``.

Типы данных даты и времени
--------------------------------

Часовые пояса
~~~~~~~~~~~~~~~~~~

В ``Firebird 4.0`` появились типы с часовыми поясами: ``TIME WITH TIME ZONE`` и ``TIMESTAMP WITH TIME ZONE``. 

Свойства соединения ``dataTypeBind`` и ``sessionTimeZone`` обеспечивают ограниченной поддержки этих типов. 

Типы часовых поясов поддерживаются в ``Java 8``. В ``Java 7`` они не поддерживаются и для их использования необходимо включить традиционное приведение часовых поясов. 
При использовании ``legacy`` ``Firebird`` будет конвертировать часовые пояса в в эквивалентные типы ``TIME`` и ``TIMESTAMP`` (``WITHOUT TIME ZONE``), 
используя часовой пояс сессии. 
Правила приведения часовых поясов можно настроить с помощью свойства соединения ``dataTypeBind``.

Область применения часовых поясов
""""""""""""""""""""""""""""""""""""

В ``JDBC 4.2`` появилась поддержка часовых поясов. Эти типы сопоставлены с ``java.time.OffsetTime`` и ``java.time.OffsetDateTime``. 
``JDBC`` не определяет явно ``set-методы`` для этих типов. 
Но можно использовать ``setObject(index, value)``, ``updateObject(index, value)``, ``getObject(index/name)`` или ``getObject(index/name, classType)``.

В ``Firebird 4.0`` часовой пояс может быть задан строкой с регионом часового пояса (например, ``America/Sao_Paulo``), 
или в виде смещения часов:минут относительно ``GMT`` (например, ``-03:00``).
``Jaybird`` по умолчанию использует часовые пояса в виде смещения. 
При получении значения с именованной зоной ``Jaybird`` постарается преобразовать его в эквивалентное смещение, 
используя информацию о часовом поясе из ``Java``. Если сопоставление недоступно, время будет возвращено в ``UTC`` (смещение ноль).

Начиная с ``Jaybird 4.0.1``, также можно извлекать и устанавливать ``java.time.ZonedDateTime``, который сохраняет информацию об именованном часовом поясе.

``Jaybird 4`` поддерживает следующие типы ``Java`` для полей c часовым поясом (те, что отмечены ``*``, не определены в ``JDBC``).

``TIME WITH TIME ZONE``:

* ``java.time.OffsetTime (default for getObject)``

    * При ``get``, если значение является именованной зоной, будет определено смещение с использованием основной даты ``2020-01-01`` (в версии ``4.0.0`` использовалась текущая дата). Смещение может отличаться от смещения ``OffsetDateTime`` для того же значения.

* ``java.time.OffsetDateTime``

    * При получении добавляется текущая дата.

        * Для именованной зоны время в ней определяется по ``2020-01-01``, а затем пересчитывается на текущую дату. В результате смещение может отличаться от ``OffsetTime``.
    
    * При установке значения информация о дате удаляется.

* ``java.time.ZonedDateTime (*)``

    * При использовании ``get`` время в зоне определяется как ``2020-01-01``, а затем пересчитывается на текущую дату.
    * При ``set`` время пересчитывается на ``2020-01-01``, а затем информация о дате удаляется.

* ``java.lang.String``

    * При ``get`` применяется ``OffsetTime.toString()`` (например, ``13:25:13.1+01:00``)
    * При ``set`` проверяет формат обработки по умолчанию либо ``OffsetTime``, либо ``OffsetDateTime`` (например, ``13:25:13.1+01:00`` или ``2019-03-10T13:25:13+01:00``) и затем устанавливает этот тип.

* ``java.sql.Time (*)``

    * При ``get`` получает ``java.time.OffsetDateTime``, преобразует его в миллисекунды временной точки и использует новое ``java.sql.Time(millis)``.
    * При set применяет ``toLocalTime()``, объединяет его с ``LocalDate.now()`` и затем определяет смещение времени для часового пояса ``JVM`` по умолчанию.

* ``java.sql.Timestamp (*)``

    * При ``get`` получает ``java.time.OffsetDateTime``, преобразует его в миллисекунды временной точки и использует новый ``java.sql.Timestamp(millis)``.
    * При ``set`` применяет ``toLocalDateTime()`` и определяет время смещения для часового пояса ``JVM`` по умолчанию.

``TIMESTAMP WITH TIME ZONE``:

* ``java.time.OffsetDateTime (default for getObject)``
* ``java.time.OffsetTime (*)``

    * При ``get`` информация о дате удаляется.
    * При ``set`` добавляется текущая дата

* ``java.time.ZonedDateTime (*)``
* ``java.lang.String``

    * При ``get`` применяется ``OffsetDateTime.toString()`` (например, ``2019-03-10T13:25:13.1+01:00``)
    * При ``set`` пытается использовать формат обработки по умолчанию либо ``OffsetTime``, либо ``OffsetDateTime`` (например, ``13:25:13.1+01:00`` или ``2019-03-10T13:25:13+01:00``), а затем устанавливает этот тип.

* ``java.sql.Time (*)``

    * При ``get`` получает ``java.time.OffsetDateTime``, преобразует его в миллисекунды временной точки и использует новое ``java.sql.Time(millis)``.
    * При ``set`` применяет ``toLocalTime()``, объединяет его с ``LocalDate.now()`` и затем определяет смещение дата-время для часового пояса ``JVM`` по умолчанию.

* ``java.sql.Timestamp (*)``

    * При ``get`` получает ``java.time.OffsetDateTime``, преобразует его в миллисекунды временной точки и использует новый ``java.sql.Timestamp(millis)``.
    * При ``set`` применяется ``toLocalDateTime()`` и определяет время смещения даты для часового пояса ``JVM`` по умолчанию.

* ``java.sql.Date (*)``

    * При ``get`` получает ``java.time.OffsetDateTime``, конвертирует его в миллисекунды временной точки и использует новую ``java.sql.Date(millis)``.
    * При ``set`` применяет ``toLocalDate()`` к началу дня и определяет время смещенной даты для часового пояса ``JVM`` по умолчанию.

В ``Firebird 4.0`` появились типы данных ``EXTENDED TIME/TIMESTAMP WITH TIME ZONE``, предназначенные только для приведения.
Они могут быть установлены через настройку правил приведения типов данных и включают дополнительное смещение в свои данные, 
так что клиенты без доступа к ``ICU`` или другим данным о часовом поясе могут использовать смещение, определенное ``Firebird``.

``Jaybird`` предоставляет минимальную поддержку для таких типов, обрабатывая их так же, как и обычные ``WITH TIME ZONE``. 
Это означает, что дополнительная информация о смещении игнорируется, 
и ``Jaybird`` всегда будет использовать информацию о часовом поясе ``Java`` для расчета смещения именованной временной зоны, 
а если она неизвестна в ``Java``, ``Jaybird`` вернется к ``UTC``, даже если фактическое смещение присутствует в типе ``'extended'``.

Поддержка типов даты и времени для legacy JDBC
""""""""""""""""""""""""""""""""""""""""""""""""""

Для типов ``WITH TIME ZONE`` в ``JDBC`` не определена поддержка ``legacy`` ``JDBC-типов`` (``java.sql.Time``, ``java.sql.Timestamp`` и ``java.sql.Date``). 
Чтобы облегчить переход и потенциальную совместимость с инструментами и библиотеками, ``Jaybird`` обеспечивает их поддержку. 
Однако рекомендуется избегать использования этих типов.

По сравнению с типами ``WITHOUT TIME ZONE`` возможны небольшие расхождения в значениях, поскольку ``Jaybird`` использует ``1970-01-01`` для ``WITHOUT TIME ZONE``, 
а для ``WITH TIME ZONE`` - текущую дату. Если это вызывает проблемы, то либо следует применить необходимые преобразования самостоятельно, 
либо включить традиционную привязку к часовому поясу, либо определить или привести столбцы к ``TIME`` или ``TIMESTAMP``.

Отсутствие поддержки для других java.time types
""""""""""""""""""""""""""""""""""""""""""""""""""""

Типы ``java.time.LocalTime``, ``java.time.LocalDateTime`` и ``java.time.LocalDate`` не поддерживаются для типов с часовым поясом.
Поддержка этих типов была бы неоднозначной. Если необходимо их использовать, то либо следует применить необходимые преобразования самостоятельно, 
либо включить традиционную привязку к часовому поясу, либо определить или привести столбцы как ``TIME`` или ``TIMESTAMP``.

``Jaybird`` также не поддерживает нестандартные расширения вроде ``java.time.Instant``.

Определение правил приведения для типов данных с часовым поясом
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

В ``Jaybird 3.0.9`` добавлено свойство подключения ``dataTypeBind`` для определения правил приведения типов данных.
Его можно использовать для настройки преобразования типов ``WITH TIME ZONE`` в другой тип данных. 
Тогда ``Firebird`` будет передавать столбцы или параметры ``TIME(STAMP) WITH TIME ZONE`` как указанный тип, 
что позволит клиентам без поддержки ``WITH TIME ZONE`` извлекать и устанавливать значения.

Свойство должно быть явно установлено, если используется ``Jaybird 4`` на ``Java 7`` или ``Jaybird 3`` (на любой версии ``Java``), и необходимо работать с типами ``WITH TIME ZONE``.
Оно также может быть использовано для инструментов или приложений, которые принимают типы ``java.sql.Time/Timestamp`` 
и не могут использовать типы ``java.time.OffsetTime/OffsetDateTime``, возвращаемые для типов ``WITH TIME ZONE``.

Чтобы сопоставить типы ``TIME WITH TIME ZONE`` и ``TIMESTAMP WITH TIME ZONE`` с ``legacy`` типами без часового пояса, можно использовать:

.. code-block::

    Properties props = new Properties();
    props.setProperty("dataTypeBind",
        "time with time zone to legacy;timestamp with time zone to legacy");

Вместо ``legacy`` можно явно указать ``time`` и ``timestamp`` соответственно.

``Firebird`` преобразует тип ``WITH TIME ZONE`` в эквивалентный тип ``WITHOUT TIME ZONE``, используя часовой пояс сессии для определения значения.

Столбцы результирующего набора и параметры подготовленных операторов будут вести себя как эквивалентные типы ``WITHOUT TIME ZONE``. 
Это преобразование не применяется к метаданным базы данных, которые всегда будут передавать информацию ``WITH TIME ZONE``.

Приведение ``TIME ZONE TO EXTENDED`` (включая варианты для конкретных типов) поддерживается только при использовании ``Jaybird`` версии ``Java 8`` или выше.

Свойство соединения sessionTimeZone
""""""""""""""""""""""""""""""""""""""""

Свойство соединения ``sessionTimeZone`` (псевдоним ``session_time_zone``) выполняет две задачи:

* определяет часовой пояс сеанса ``Firebird 4.0``;
* указывает часовой пояс, который следует использовать при преобразовании значений без типов часовых поясов в ``legacy`` типы даты и времени ``JDBC``.

Допустимыми значениями являются имена часовых поясов, известные ``Firebird``. 
Рекомендуется использовать подробные имена (например, ``Europe/Amsterdam``), а не двусмысленные короткие идентификаторы (например, ``CET``). 

В ``Jaybird 3`` ``sessionTimeZone`` настраивает только часовой пояс сессии на стороне сервера. 
На стороне клиента ``Jaybird`` продолжит использовать часовой пояс ``JVM`` по умолчанию для обработки значений без часового пояса в типах ``java.sql.Time/Timestamp/Date``. 
Установка ``sessionTimeZone`` в часовой пояс по умолчанию ``JVM`` даст правильные значения, 
но отказ от установки (и, таким образом, использование значения сервера по умолчанию) сохранит поведение, обратно совместимое с поведением предыдущих версий ``Jaybird``. 
В ``Jaybird 4`` это свойство также настраивает разбор значений на стороне клиента для этих ``legacy`` типов.

В ``Jaybird 3`` рекомендуется не устанавливать это свойство или установить часовой пояс ``JVM`` по умолчанию. 
Если установлено значение другого часового пояса, то рекомендуется не использовать ``legacy`` типы ``java.sql.Time/Timestamp/Date``, 
а вместо них использовать ``java.time.LocalTime/LocalDateTime/LocalDate``.

По умолчанию ``Jaybird 4`` и выше использует часовой пояс ``JVM`` по умолчанию, о котором сообщает ``java.util.TimeZone.getDefault().getID()`` в качестве часового пояса сессии. 
Использование часового пояса ``JVM`` по умолчанию является наилучшим вариантом в соответствии с требованиями ``JDBC`` в отношении ``java.sql.Time`` и ``java.sql.Timestamp``, 
использующих часовой пояс ``JVM`` по умолчанию.

Чтобы использовать часовой пояс сервера по умолчанию, 
а в ``Jaybird 3`` и более ранних версиях использовать часовой пояс ``JVM`` по умолчанию, необходимо установить свойство соединения для сервера. 
Если ``Firebird`` и ``Java`` находятся в разных часовых поясах, это невозможно.

Часовой пояс сеанса Firebird
""""""""""""""""""""""""""""""""""

Часовой пояс сессии используется для преобразования между значениями ``WITH TIME ZONE`` и ``WITHOUT TIME ZONE`` (т.е. с помощью ``cast`` или с ``legacy`` приведения типов), 
а также для значений ``LOCALTIME``, ``LOCALTIMESTAMP``, ``CURRENT_TIME`` и ``CURRENT_TIMESTAMP``, и других случаев использования часового пояса сессии.

Значение ``sessionTimeZone`` должно поддерживаться ``Firebird 4.0``. Возможно, что идентификаторы часовых поясов, используемые в ``Java``, не поддерживаются ``Firebird``. 
Если ``Firebird`` не знает часовой пояс сессии, при подключении будет получена ошибка (``Invalid time zone region: <имя зоны>``).

В ``Jaybird 4`` и выше будет использоваться часовой пояс ``JVM`` по умолчанию в качестве часового пояса сеанса по умолчанию. 
Использование часового пояса ``JVM`` по умолчанию в качестве часового пояса сеанса по умолчанию приведет к изменению поведения по сравнению с предыдущими версиями ``Jaybird``, 
поскольку значения текущего времени, такие как ``LOCALTIMESTAMP`` (и т.д.), теперь будут отображать время в часовом поясе ``JVM``, 
а не в часовом поясе сервера, перенесенном на часовой пояс ``JVM`` по умолчанию.

Например, если ``Firebird`` находится в ``Europe/London``, а Java-приложение - в ``Europe/Amsterdam`` с временем ``12:00`` в ``Firebird``, 
то в ``Jaybird 3`` Java-приложение представит это время как ``12:00``, а в ``Jaybird 4`` с ``Firebird 4.0`` - как ``13:00``, поскольку это время в Амстердаме, 
если в Лондоне ``12:00`` (без учета потенциальных различий в начале и конце ``DST``).

Часовой пояс сессии для преобразования
""""""""""""""""""""""""""""""""""""""""

Для типов ``WITHOUT TIME ZONE`` временная зона сеанса будет использоваться для получения значений ``java.sql.Time``, ``java.sql.Timestamp`` и ``java.sql.Date``. 
Это также выполняется в ``Firebird 3.0`` и более ранних версиях.

Если ``Java`` не знает часовой пояс сеанса, то ошибки не будет, но при получении ``java.sql.Time``, ``java.sql.Timestamp`` или ``java.sql.Date`` будет получено предупреждение, 
и преобразование будет происходить в ``GMT``, что может привести к неожиданным значениям.

Рекомендуется использовать типы ``java.time.LocalTime``, ``java.time.LocalDateTime`` и ``java.time.LocalDate`` вместо устаревших типов даты и времени.

Для типов ``WITH TIME ZONE`` часовой пояс сессии не влияет на преобразование в ``legacy`` ``JDBC`` типы даты/времени: смещенная дата/время преобразуется 
в миллисекунды временной точки и используется для формирования этих ``legacy`` типов напрямую.

Выполнение оператора ``SET TIME ZONE <имя зоны>`` после подключения изменит часовой пояс сеанса на сервере, 
но ``Jaybird`` продолжит использовать часовой пояс сеанса, установленный в свойстве подключения, для этих преобразований.

Поддержка часовых поясов для CONVERT
""""""""""""""""""""""""""""""""""""""""""

В ``Jaybird`` добавлено расширение ``JDBC-функции`` ``CONVERT``, чтобы обеспечить преобразование в типы временных зон.

В дополнение к стандартным типам также поддерживаются ``TIME_WITH_TIME_ZONE``, ``TIME_WITH_TIMEZONE``, ``TIMESTAMP_WITH_TIME_ZONE`` и ``TIMESTAMP_WITH_TIMEZONE`` (и то же самое с префиксом ``SQL``).

Предостережения для использования типов с часовым поясом
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

* Поля с часовыми поясами не поддерживают ``java.time.LocalDate``, ``java.time.LocalTime``, ``java.time.LocalDateTime``.
* ``Firebird 4.0`` переопределил ``CURRENT_TIME`` и ``CURRENT_TIMESTAMP``, чтобы возвращать тип ``WITH TIME ZONE``. Необходимо использовать ``LOCALTIME`` и ``LOCALTIMESTAMP``, если необходимо обеспечить использование типа ``WITHOUT TIME ZONE``.
* Метаданные базы данных всегда будут возвращать совместимую с ``JDBC 4.2`` информацию о типах с часовым поясом, даже на ``Java 7``, и даже если установлено традиционное приведение часовых поясов. Для совместимости с ``Java 7`` константы ``JDBC 4.2`` ``java.sql.Types TIME_WITH_TIMEZONE`` и ``TIMESTAMP_WITH_TIMEZONE`` определены также в ``org.firebirdsql.jdbc.JaybirdTypeCodes``.
* По умолчанию ``sessionTimeZone`` устанавливается в часовой пояс ``JVM`` по умолчанию, что может привести к различному поведению приложения для ``DATE``, ``TIME`` и ``TIMESTAMP``, включая значения, генерируемые в триггерах и в предложениях значений по умолчанию. Чтобы предотвратить это, следует заменить эти типы на ``WITH TIME ZONE``, либо установить ``sessionTimeZone`` на ``server`` или на фактический часовой пояс сервера ``Firebird``.
* Поскольку ``CURRENT_TIME`` использует часовой пояс сессии, который обычно является именованной зоной, в сочетании с ``java.time.OffsetTime`` могут быть неоднозначные результаты. Например, если текущая дата и время - ``'2020-07-01T14:51:00 Europe/Amsterdam'``, то ``CURRENT_TIME`` вернет значение ``'14:51:00+01:00'``, а не ``'14:51:00+02:00'``. Рекомендуется вместо ``CURRENT_TIME`` использовать ``CURRENT_TIMESTAMP``.
* Использование ``TIME WITH TIME ZONE`` с именованными зонами довольно нестабильно и может привести к ошибкам интерпретации. В ``Firebird`` значения хранятся в ``UTC`` с их смещением или именованными зонами, где при определении времени в именованной зоне необходимо использовать ``2020-01-01`` в качестве даты для применения правил часового пояса. Рекомендуется по возможности не использовать ``TIME WITH TIME ZONE``. 

Десятичные числа с плавающей точкой типа DECFLOAT
----------------------------------------------------

В ``Firebird 4.0`` появился тип данных ``SQL:2016 DECFLOAT`` - десятичное число с плавающей точкой с точностью 16 или 34 разряда (с поддержкой ``IEEE-754 Decimal64`` или ``Decimal128``). 

В ``Jaybird 4`` появилась поддержка отображения типа данных ``DECFLOAT`` на ``java.math.BigDecimal``.

Способы решения проблемы для Jaybird 3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``Jaybird 3`` не поддерживает ``DECFLOAT``, но начиная с ``Jaybird 3.0.9``, свойство ``dataTypeBind`` можно использовать для преобразования в тип данных, поддерживаемый ``Jaybird``.

Рекомендуется использовать либо ``dataTypeBind=decfloat`` для ``varchar``, либо ``dataTypeBind=decfloat`` для ``double precision``. 
Предпочтительнее вариант ``varchar``, поскольку он поддерживает весь диапазон значений ``DECFLOAT``.

В более ранних версиях ``Jaybird 3`` можно использовать оператор ``SET BIND OF DECFLOAT TO <target-type>``, чтобы настроить соединение на отображение ``DECFLOAT`` в другой тип данных. 
Тогда ``Firebird`` будет представлять столбцы или параметры ``DECFLOAT`` как указанный тип, позволяя клиентам без поддержки ``DECFLOAT`` читать или устанавливать значения. 

Например:

.. code-block::

    try (Connection connection = DriverManager.getConnection(..);
        Statement stmt = connection.createStatement()) {
        stmt.execute("SET BIND OF DECFLOAT TO varchar");
        // DECFLOAT will now be mapped to a VARCHAR datatype
    }

.. warning::

    Действие оператора ``SET BIND`` будет возвращено к значению по умолчанию при выполнении ``ALTER SESSION RESET``.

Определение правил приведения типа данных decfloat
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В ``Jaybird 3.0.9`` добавлено свойство соединения ``dataTypeBind`` для определения отображений типов данных. 
Его можно использовать для настройки приведения ``DECFLOAT`` в другой тип данных. 
При использовании этого свойства ``Firebird`` будет представлять столбцы или параметры ``DECFLOAT`` как указанный тип, 
позволяя клиентам без поддержки ``DECFLOAT`` читать или устанавливать значения.

Чтобы сопоставить ``DECFLOAT(16)`` с ``DOUBLE PRECISION`` и ``DECFLOAT(34)`` со строкой, можно использовать:

.. code-block::

    Properties props = new Properties();
    props.setProperty("dataTypeBind", "decfloat to varchar")

Чтобы сопоставить ``DECFLOAT(16)`` с ``DOUBLE PRECISION`` и ``DECFLOAT(34)`` со строкой, можно использовать:

.. code-block::

    Properties props = new Properties();
    props.setProperty("dataTypeBind", "decfloat(16) to double precision;decfloat(34) to varchar")

``Firebird`` преобразует тип ``DECFLOAT`` в указанный тип, используя приведение для получения значения.

Столбцы результирующего набора и параметры подготовленных операторов будут работать как указанный тип. 
Это преобразование не применяется к метаданным базы данных, которые всегда будут сообщать информацию ``DECFLOAT``.

В большинстве случаев рекомендуется устанавливать приведение к ``VARCHAR``, так как это позволит получать (и устанавливать) весь диапазон значений ``DECFLOAT`` с высокой точностью.

Поддержка DECFLOAT 
~~~~~~~~~~~~~~~~~~~~~~

В ``Jaybird 4`` появилась поддержка типа данных ``DECFLOAT``. Типом объекта по-умолчанию для ``DECFLOAT`` является ``java.math.BigDecimal``, 
но поддерживается преобразование из следующих типов данных и в них:

* ``java.math.BigDecimal``;
* ``byte`` (доступны значения от -128 до 127(!));
* ``short`` (доступны значения -32768 до 32767); 
* ``int`` (доступны значения :math:`-2^{31}` до :math:`2^{31}-1`);
* ``long`` (доступны значения :math:`-2^{63}` до :math:`2^{63}-1`);
* ``float`` (доступны значения ``-1 * Float.MAX_VALUE`` до ``Float.MAX_VALUE``);
* ``double`` (доступны значения ``-1 * Double.MAX_VALUE`` до ``Double.MAX_VALUE``);
* ``boolean``;
* ``java.lang.String``;
* ``java.math.BigInteger``;
* ``org.firebirdsql.extern.decimal.Decimal32/64/128``.

Тип ``DECFLOAT`` еще не определен в спецификации ``JDBC``. На данный момент ``Jaybird`` определяет код типа, специфичный для ``Jaybird``, со значением ``-6001``. 
Это значение доступно через константу ``org.firebirdsql.jdbc.JaybirdTypeCodes.DECFLOAT``, для ``JDBC 4.2`` и выше - ``org.firebirdsql.jdbc.JaybirdType.DECFLOAT``, 
которая является перечислением, реализующим ``java.sql.SQLType``.

Если необходимо использовать код типа, рекомендуется использовать константы. 
Если константа типа ``DECFLOAT`` будет добавлена в стандарт ``JDBC``, её значение обновится. 

Точность и диапазон
""""""""""""""""""""""""

Тип данных ``DECFLOAT`` поддерживает значения с точностью до 16 или 34 десятичных цифр и экспонентой от -398 до 369 (``DECFLOAT(16)``) или от -6176 до 6111 (``DECFLOAT(34)``), 
поэтому минимальное и максимальное значения равны:

.. tabularcolumns:: |>{\ttfamily\arraybackslash}\X{5}{15}|>{\ttfamily\arraybackslash}\X{5}{15}|>{\ttfamily\arraybackslash}\X{5}{15}|
.. list-table:: 
   :class: longtable
   :header-rows: 1

   * - Тип
     - Диапазон значений
     - Наименьшее значение
   * - DECFLOAT(16)
     - +/-9.9..9E+384 (16 знаков)
     - +/-1E-398 (1 знак)
   * - DECFLOAT(34)
     - +/-9.9..9E+6144 (34 знака)
     - +/-1E-6176 (1 знак)

При преобразовании значений из типов ``Java`` в ``DECFLOAT`` и получении значений ``DECFLOAT`` в формате ``Decimal32`` или ``Decimal64`` применяются следующие правила:

* Нулевые значения могут иметь ненулевую экспоненту, и если экспонента выходит за пределы диапазона, значение экспоненты «сжимается» до минимальной или максимальной поддерживаемой экспоненты.
* Значения с точностью, превышающей заданную, округляются до заданной точности с помощью ``RoundingMode.HALF_EVEN``.
* Если величина (или экспонента) слишком мала, то выполняются следующие действия:

    1. Точность уменьшается с применением ``RoundingMode.HALF_EVEN``, увеличивая экспоненту на величину уменьшения точности.
       
       Пример: ``DECFLOAT(16)`` хранит значения в виде интегрального коэффициента из 16 цифр и экспоненты от -398 до +369. 
       Значение 1.234567890123456E-394 или 1234567890123456E-409 имеет коэффициент 1234567890123456 и экспоненту -409. 
       Коэффициент состоит из 16 цифр, но экспонента слишком мала и составляет 11.

       Если пожертвовать наименьшими значащими цифрами, то можно увеличить экспоненту, для этого нужно разделить коэффициент на :math:`10^{11}` (и округлить) и увеличить экспоненту на 11. 
       Получается экспоненту = round(1234567890123456 / :math:`10^{11}`) = 12346 и экспоненту = -409 + 11 = -398.

       Полученное значение теперь равно ``12346E-398`` или ``1,2346E-394``.
    
    2. Если после предыдущего шага величина все еще слишком мала, возникает переполнение, и значение усекается до 0 с минимальной экспонентой и сохранением знака, например, для ``DECFLOAT(16)`` значение станет ``+0E+398`` или ``-0E-398``. Технически это просто частный случай предыдущего шага.

* Если величина (или экспонента) слишком велика, то выполняются следующие действия:

    1. Если точность меньше максимальной, а разница между максимальной и фактической точностью больше или равна разнице между фактической экспонентой и максимальной экспонентой, то точность увеличивается путем добавления нулей в качестве наименьших значащих цифр и уменьшения экспоненты на количество добавленных нулей.

       Пример: ``DECFLOAT(16)`` хранит значения в виде интегрального коэффициента из 16 цифр и экспоненты в диапазоне от -398 до +369. 
       Значение 1E+384 - это коэффициент 1 с экспонентой 384. Это слишком много для максимальной экспоненты, однако есть значение с одной цифрой, 
       что оставляет 15 неиспользованных старших разрядов.

       Если умножить коэффициент на :math:`10^{15}` и вычесть 15 из экспоненты, то получится: коэффициент = 1 * :math:`10^{15}` = 1000000000000000 и экспонента = 384 - 15 = 369. Такие значения коэффициента и экспоненты находятся в диапазоне требований к хранению.

       Полученное значение теперь равно 1000000000000000E+369 или 1,000000000000000E+384.

    2. В противном случае произойдет переполнение и будет получено ``SQLException``.

Настройка ошибок и округления decfloat
""""""""""""""""""""""""""""""""""""""""""

Чтобы настроить поведение ошибок и округления на стороне сервера для типов данных ``DECFLOAT``, можно использовать следующие свойства соединения:

* ``decfloatRound`` (псевдоним: ``decfloat_round``) - возможные значения: ``ceiling``, ``up``, ``half_up`` (по умолчанию), ``half_even``, ``half_down``, ``down``, ``floor``, ``reround``.
* ``decfloatTraps`` (псевдоним: ``decfloat_traps``) - список с опциями, разделенными запятыми: ``Division_by_zero`` (по умолчанию), ``Inexact``, ``Invalid_operation`` (по умолчанию), ``Overflow`` (по умолчанию), ``Underflow``.

Настройка этих параметров изменяет только поведение сервера.

Примечания
""""""""""""""

1. ``java.math.BigDecimal`` способен представлять числа с большей точностью, чем ``DECFLOAT``, а также числа, выходящие за пределы диапазона. Для вычислений в ``Java`` необходимо использовать ``MathContext.DECIMAL64`` (для ``DECFLOAT(16)``) или ``MathContext.DECIMAL128`` (для ``DECFLOAT(34)``), чтобы получить такие же результаты, как и в ``Firebird``.
   ``Firebird 4.0`` в настоящее время позволяет хранить значения ``NaN`` и ``Infinity``, извлечение этих значений приведет к ``SQLException`` с ошибкой ``DecimalInconvertibleException``.
2. Байт в ``Java`` является значащим, ``Jaybird`` сохраняет знак при хранении байтовых значений и считает значения за пределами -128 и +127 выходящими за пределы диапазона.
3. Все интегральные значения - если они находятся в пределах диапазона - сначала преобразуются в ``long`` с помощью ``BigDecimal.longValue()``, которая отбрасывает все дробные части (округление путем усечения).
4. При хранении ``long`` в ``DECFLOAT(16)`` округление будет применяться с использованием ``RoundingMode.HALF_EVEN`` для значений больше 9999999999999999L или меньше -999999999999999999L.
5. Значения ``float`` сначала преобразуются в ``double`` (или из ``double``), что может привести к разнице в округлении.
6. ``float`` и ``double`` могут быть полностью сохранены в ``DECFLOAT(16)`` и ``DECLOAT(34)``, с небольшими различиями в округлении.
7. При чтении значений ``DECFLOAT`` как ``double`` или ``float`` будет применяться округление, поскольку двоичные типы с плавающей точкой обладают меньшей точностью.
8. Если величина значения ``DECFLOAT`` слишком большая для представления в ``float`` или ``double``, может быть возвращено значение ``+Infinity`` или ``-Infinity`` (см. ``BigDecimal.doubleValue()``).
9. В настоящее время поддерживается хранение и получение значений ``NaN``, ``+Infinity`` и ``-Infinity``, но это может измениться, поскольку стандарт ``SQL:2016`` этого не допускает.
10. При установке логических значений 0 (или ``0E+0``) будет означать ``false``, а 1 (или ``1E+0``) - ``true``.
11. При получении значения в виде логической операции будет возвращено ``true`` для 1 (ровно ``1E+0``) и ``false`` для всех остальных значений. Это означает, что ``1.0E+0`` (или ``10E-1``) и т. д. будут ``false``.
12. Установка значений как ``String`` поддерживается в соответствии с правилами формата нового ``BigDecimal(String)``, с дополнительной поддержкой специальных значений ``+NaN``, ``-NaN``, ``+sNaN``, ``-sNaN``, ``+Infinity`` и ``-Infinity`` (без учета регистра). Другие нечисловые строки вызовут ``SQLException`` с исключением ``NumberFormatException``.
13. Получение значений в виде ``String`` будет эквивалентно ``BigDecimal.toString()``, с поддержкой специальных значений, упомянутых в предыдущей заметке.
14. Поддержка специальных значений находится в стадии разработки может измениться в следующих версиях ``Firebird`` и/или ``Jaybird``.
15. При получении в виде ``BigInteger`` будет использоваться функция ``BigDecimal.toBigInteger()``, которая отбрасывает дробную часть (округление путем усечения) и может добавлять (-1 * масштаб - точность) наименее значимые нули, если масштаб превышает точность. Использование ``BigInteger`` для больших значений может привести к значительному расходу памяти.
16. При установке значения ``BigInteger`` теряется точность для значений, содержащих больше цифр, чем целевой тип.
17. Значения также могут быть заданы и получены как типы ``Decimal32``, ``Decimal64`` и ``Decimal128`` из пакета ``org.firebirdsql.extern.decimal``. При этом ``Decimal64`` точно соответствует формату протокола ``DECFLOAT(16)``, а ``Decimal128`` - формату протокола ``DECFLOAT(34)``.
18. При установке ``Decimal128`` в ``DECFLOAT(16)``, ``Decimal32`` в ``DECFLOAT(16)`` или ``DECFLOAT(34)``, а также при получении ``Decimal32`` из ``DECFLOAT(16)`` или ``DECFLOAT(34)`` или ``Decimal64`` из ``DECFLOAT(34)`` будут применяться правила, описанные в разделе `Точность и диапазон`_.
19. Нулевые значения могут иметь знак (например, -0 против 0 (+0)), его можно установить или получить только с помощью типов ``String`` или ``DecimalXX``, или в результате округления.

Числовые типы DECIMAL/NUMERIC c указанной точностью
------------------------------------------------------

Типы ``JDBC`` ``DECIMAL`` и ``NUMERIC`` поддерживаются ``Firebird`` и ``Jaybird`` и отображаются на ``java.math.BigDecimal``.

Поведение ``NUMERIC`` в ``Firebird`` ближе к поведению ``DECIMAL`` в стандарте ``SQL``. Указанная точность - это минимальная точность.

Точность и диапазон DECIMAL и NUMERIC
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В ``Firebird 3.0`` и более ранних версиях максимальная точность ``DECIMAL`` и ``NUMERIC`` равна 18, а максимальный масштаб - 18.

В ``Firebird 4.0`` максимальная точность и масштаб ``DECIMAL`` и ``NUMERIC`` были увеличены до 38. 
Любой ``NUMERIC`` или ``DECIMAL`` с точностью от 19 до 38 позволяет хранить данные с точностью до 38.

В ``Firebird`` точность поддерживается ``Int128``.

Значения, установленные для поля или параметра, будут округлены до целевого масштаба поля с использованием ``RoundingMode.HALF_EVEN``. 
Значения, превышающие точность 38 после округления, будут отклонены с ``TypeConversionException``.

Тип INT128
-------------

В ``Firebird 4.0`` появился тип ``INT128``, представляющий собой знаковое 128-битное число.

Поддержка INT128
~~~~~~~~~~~~~~~~~~~~~~

В ``Jaybird 4.0.1`` появилась поддержка типа ``INT128``. ``Jaybird 4.0.0`` также может работать с этим типом, но формально не определяет его как ``INT128``.

Поскольку ``JDBC`` не определяет тип ``INT128``, ``Jaybird`` сопоставляет тип ``Firebird`` ``INT128`` с типом ``NUMERIC`` с точностью 38. 
Таким образом, большинство инструментов смогут обрабатывать весь диапазон значений без проблем.