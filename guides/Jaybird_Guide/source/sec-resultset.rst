Работа с результирующим набором
=====================================

Выполнение оператора ``SELECT`` позволяет получить возвращаемые результаты запроса с помощью интерфейса ``java.sql.ResultSet``.

Параметры ResultSet
-----------------------

Типы ResultSet
~~~~~~~~~~~~~~~~~~

Спецификация ``JDBC`` определяет три типа результирующих наборов:

* ``TYPE_FORWARD_ONLY`` - не прокручиваемый результирующий набор, курсор в наборе может двигаться только вперед.
  При использовании уровня изоляции ``TRANSACTION_READ_COMMITTED`` в результирующем наборе будут возвращены все строки, 
  удовлетворяющие условию поиска на момент выбора (каждый вызов ``ResultSet.next()`` вернет установленный размер выборки (``fetch size``)).
  В других случаях в результате будут только те строки, которые были видны на момент старта транзакции.
* ``TYPE_SCROLL_INSENSITIVE`` - результирующий набор является прокручиваемым, курсор может перемещаться вперед и назад,
  может позиционироваться на указанной строке. Видны только строки, удовлетворяющие условию на момент выполнения запроса.
* ``TYPE_SCROLL_SENSITIVE`` - не поддерживается ``Firebird`` и ``Jaybird``.
  ``Jaybird`` позволяет приложению запросить такой результирующий набор,
  но в соответствии со спецификацией ``JDBC`` тип будет "понижен" до ``TYPE_SCROLL_INSENSITIVE``, а в объект соединения добавляется соответствующее предупреждение.

Из-за отсутствия поддержки прокручиваемых курсоров в ``Firebird 4.0`` и более ранних версиях, набор результатов типа ``TYPE_SCROLL_INSENSITIVE``
реализован путем получения полного набора результатов на клиенте. Прокрутка происходит в памяти клиента.
Это может негативно сказаться на использовании системной памяти и производительности, если набор результатов большой.

Начиная с ``Firebird 5.0``, поддерживаются прокручиваемые курсоры на стороне сервера.
В ``Jaybird 5`` появилась поддержка прокрутки не удерживаемого набора результатов 
при ``PURE_JAVA`` (не ``native`` или ``embedded``) подключении с параметром ``scrollableCursor = SERVER``.
В следующей версии это может быть поведением по умолчанию.

Согласованность результирующего набора
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Согласованность результирующего набора определяет, можно ли обновлять объект ``ResultSet`` напрямую или для обновления строки следует использовать отдельный ``SQL-запрос``.
Наборы результатов, допускающие прямое изменение с помощью методов ``ResultSet.updateXXX``,
обычно используются в приложениях с графическим интерфейсом, которые позволяют редактировать результирующий набор на месте.

Согласованность результирующего набора задается во время создания оператора и не может быть изменена позже. ``Jaybird`` поддерживает два типа согласованности:

* ``CONCUR_READ_ONLY`` доступен для всех типов результирующих наборов.
  При нём прямое обновление результирующего набора невозможно и все методы ``ResultSet.updateXXX`` должны вызывать исключение.
* ``CONCUR_UPDATABLE`` поддерживается только при следующих условиях, чтобы драйвер правильно построил ``DML-запрос``, изменяющий только одну строку:

	* Оператор ``SELECT`` ссылается только на одну таблицу;
	* Все столбцы, на которые не ссылается оператор ``SELECT``, допускают значения ``NULL``;
	* Оператор ``SELECT`` не содержит предиката ``DISTINCT``, агрегатных функций, соединенных таблиц или хранимых процедур;
	* Оператор ``SELECT`` ссылается на все столбцы первичного ключа таблицы или на столбец ``RDB$DB_KEY``.

Доступность результирующего набора
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Доступность результирующего набора сообщает драйверу, следует ли оставлять наборы результатов открытыми после фиксации.
``ResultSet.HOLD_CURSORS_OVER_COMMIT`` оставляет результирующий набор открытым,
а ``ResultSet.CLOSE_CURSORS_AT_COMMIT`` закрывает их при фиксации.

Когда приложение вызывает ``Connection.commit()``, сервер ``Firebird`` закрывает все открытые результирующие наборы.
Невозможно указать серверу оставить результирующий набор открытым после фиксации, если только не используется режим ``commit retaining``.
Этот режим является глобальным для всего соединения и не подходит для контроля хранения на уровне оператора.
Использование режима ``commit retaining`` c транзакциями ``read-write`` препятствует сборке мусора, не используется в ``Jaybird`` во время обычного выполнения.
Можно зафиксировать транзакцию, оставив результирующие наборы открытыми, выполнив ``SQL-оператор`` ``COMMIT RETAIN``.

Для сохранения результирующего набора ``Jaybird`` переводит его в тип ``TYPE_SCROLL_INSENSITIVE``, 
чтобы кэшировать все строки локально, даже если был запрошен тип ``TYPE_FORWARD_ONLY``.

Если значение столбца не является целым числом, Jaybird пытается преобразовать его в соответствии с :ref:`data_type_conversion`.

При подключении к ``Firebird 5.0`` с ``Jaybird 5`` или выше и параметром подключения ``scrollableCursor=SERVER``,
сохраняемый результирующий набор не будет использовать прокручиваемый курсор на стороне сервера,
а вместо этого будет эмулироваться с помощью кэширования. Прокручиваемые курсоры на стороне сервера не поддерживают удерживающее поведение.

Управление результирующим набором
-------------------------------------

Объекты ``ResultSet`` создаются при вызове методов ``Statement.executeQuery(String)`` или ``Statement.getResultSet()``,
а также при получении сгенерированных ключей из ``Statement.getGeneratedKeys()``.
``Statement.getResultSet()`` используется вместе с ``Statement.execute(String)`` и может быть вызван только один раз для каждого результирующего набора.

Использование метода ``Statement.executeQuery(String)``:

.. code-block::

	try (Statement stmt = connection.createStatement();
		 ResultSet rs = stmt.executeQuery("SELECT * FROM myTable")) {
	  // process result set
	}

Использование метода ``Statement.getResultSet()``:

.. code-block::

	try (Statement stmt = connection.createStatement()) {
		boolean hasResultSet = stmt.execute("SELECT * FROM myTable");
		if (hasResultSet) {
			try (ResultSet rs = stmt.getResultSet()) {
			  // process result set
			}
		}
	}

Обращение к значениям в результирующем наборе
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В зависимости от типа результирующего набора можно перемещать курсор либо только вперед, либо с использованием абсолютного и относительного позиционирования.

Значения из результирующего набора можно получить, вызвав метод get, соответствующий типу столбца.
Например, метод ``ResultSet.getInt(1)`` возвращает значение первого столбца в виде значения ``int``.
Если значение столбца не является целым числом, ``Jaybird`` пытается преобразовать его в соответствии с ``Таблицей преобразования типов данных``.

Есть два способа получения данных из столбцов результирующего набора: по метке столбца или по его позиции.
Позиция первого столбца равна 1. Имена, передаваемые методам get, не чувствительны к регистру.
Поиск происходит только в псевдонимах столбцов - или, в терминологии JDBC, в метке столбца.
Если у столбца нет псевдонима, оригинальное имя столбца считается его псевдонимом.
Если существует более одного столбца, соответствующего указанному имени будет взят первый.

Если используются ``get-методы`` для примитивных типов и значение в наборе результатов равно ``NULL``,
драйвер возвращает значение по умолчанию для этого типа.
Например, метод ``getInt()`` вернет 0. Чтобы узнать, значение равно 0 или ``NULL``, необходимо вызвать метод ``ResultSet.wasNull()`` после вызова метода ``get``.

``Get-методы``, возвращающие значения объектов (``getString``, ``getDate``, ``getObject`` и т.д.), вернут нулевое значение для столбцов, содержащих ``NULL``.
Вызов ``wasNull`` после методов получения объектов возможен, но не нужен.

Пример использования результирующего набора:

.. code-block::

	try (Statement forwardStatement = connection.createStatement();
		ResultSet rs = forwardStatement.executeQuery(
			"SELECT id, name, price FROM myTable")) {

		while(rs.next()) {
			int id = rs.getInt(1);
			String name = rs.getString("name");
			double price = rs.getDouble(3);
		}
	}

Обновление записей в результирующем наборе
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Прокручиваемые курсоры полезны, когда результат запроса отображается приложением,
которое позволяет пользователю редактировать данные и отправлять изменения в базу данных.

Пример обновления записей в результирующем наборе:

.. code-block::

	try (Statement scrollStatement = connection.createStatement(
			ResultSet.TYPE_SCROLL_INSENSITIVE,
			ResultSet.CONCUR_UPDATABLE);
		ResultSet rs = scrollStatement.executeQuery(
			"SELECT id, name, price FROM myTable");
		rs.absolute(1);                  // move to the first row
		rs.updateString(2, anotherName); // update the name
		rs.updateRow();                  // post changes to the db

		rs.moveToInsertRow();
		rs.updateInt(1, newId);
		rs.updateString(2, newName);
		rs.updateDouble(3, newPrice);
		rs.insertRow();
		rs.moveToCurrentRow();

		rs.relative(-2);
	}

В примере показано, как обновить первую строку, вставить новую и после этого переместить две записи назад.

Также можно обновлять текущую строку с помощью "позиционных обновлений" для именованных курсоров. Это работает только с однонаправленными курсорами,
поскольку можно обновить только строку, на которую указывает курсор на стороне сервера.
В случае прокручиваемых курсоров клиенту передается полный набор результатов, а затем закрывается курсор на стороне сервера.

Сначала нужно указать имя курсора и список столбцов, которые будут обновлены перед выполнением запроса.
Это имя впоследствии будет использовано в операторе ``UPDATE``, как показано в примере ниже.

Пример использования позиционированных обновлений:

.. code-block::

	connections.setAutoCommit(false);
	try (Statement selectStmt = connection.createStatement();
		Statement updateStmt = connection.createStatement()) {
		selectStmt.setCursorName("someCursor");

		try (ResultSet rs = selectStmt.executeQuery(
				"SELECT id, name, price FROM myTable " +
				"FOR UPDATE OF myColumn")) {

			while(rs.next()) {
			...
			if (someCondition) {
				updateStmt.executeUpdate("UPDATE myTable " +
					"SET myColumn = myColumn + 1 " +
					"WHERE CURRENT OF " + rs.getCursorName());
			}
			}
		}
	}

Закрытие результирующего набора
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Результирующий набор закрывается вызовом метода ``ResultSet.close()``.
При этом освобождаются связанные с ним ресурсы сервера и объект ``ResultSet`` становится доступным для сборки мусора.
Рекомендуется явно закрывать результирующие наборы в режиме ``auto-commit`` и результирующие наборы ``ResultSet.TYPE_SCROLL_INSENSITIVE``,
поскольку при этом освобождается память, используемая для кэшированных данных. Также рекомендуется использовать ``try-with-resources``.

Объект результирующего набора автоматически закрывается при закрытии или повторном выполнении создавшего его оператора.
В режиме ``auto-commit`` результирующий набор закрывается автоматически, если любой оператор выполнился в том же соединении.
