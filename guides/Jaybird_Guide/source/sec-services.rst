Работа с сервисами
=====================

В дополнение к обычным соединениям с базой данных, ``Firebird`` имеет серверные соединения.
Они используются для выполнения различных административных задач, например, резервного копирования, поддержки, сбора статистики.
Набор вызовов ``API`` для выполнения таких задач называется ``Services API``.
Клиентские приложения могут использовать ``Services API`` для получения некоторой ограниченной информации об окружении и конфигурации сервера.

Вызовы ``Services API`` можно рассматривать как задачи, вызванные клиентским приложением, которые должны быть выполнены на сервере.
Параметры, передаваемые в вызовах, используются для создания аргументов, аналогичных тем, что передаются утилитами командной строки.
далее эти аргументы передаются во входные параметры утилиты ``gbak``, ``gfix``, ``gsec`` или ``gstat``.
Выводы утилит передаются по сети клиентскому приложению.

``Jaybird`` предоставляет набор интерфейсов для выполнения административных задач независимо от режима использования
(т.е. удаленный сервер и встроенный сервер, проводной протокол и доступ через собственную клиентскую библиотеку).

В этой главе описывается ``Java API`` для административных задач. Все классы и интерфейсы, описанные ниже, определены в пакете ``org.firebirdsql.management``.
Каждый класс работает как отдельный объект и не требует открытого соединения с сервером.

ServiceManager
------------------

Интерфейс ``ServiceManager`` и класс ``FBServiceManager`` определены как общие суперклассы, предоставляющие get и set методы для общих свойств,
а также некоторые общие процедуры. Можно указать следующие свойства:

.. tabularcolumns:: |>{\ttfamily\arraybackslash}\X{6}{30}|>{\ttfamily\arraybackslash}\X{8}{30}|>{\arraybackslash}\X{16}{30}|
.. list-table::
   :class: longtable
   :header-rows: 1

   * - Свойство
     - Тип
     - Описание
   * - host

       serverName
     - String
     - Имя или ``IP-адрес`` узла, к которому будет отправлен запрос ``Service API``. Обязательный параметр.
   * - port

       portNumber
     - int
     - Порт, на который отправляется запрос, по умолчанию 3050.
   * - database
     - String
     - Путь к базе данных. Значение свойства зависит от вызываемой службы и будет описано в каждом из разделов ниже.
   * - user
     - String
     - Пользователь, от имени которого будут выполняться все вызовы ``Service API``. Обязательный параметр.
   * - password
     - String
     - Пароль, соответствующий указанному пользователю. Обязательный параметр.
   * - roleName
     - String
     - Роль.
   * - expectedDb
     - String
     - В ``Firebird 3.0`` и выше это значение используется для поиска базы данных безопасности не по умолчанию, которую следует использовать при аутентификации. Значение - это путь к базе данных или псевдоним.
   * - authPlugins
     - String
     - Список плагинов аутентификации, которые необходимо использовать (игнорируется для ``Firebird 2.5`` или более ранних версий). Используйте ``null`` (по умолчанию), чтобы оставить настройки ``Jaybird`` по умолчанию.
   * - processId
     - int
     - Идентификатор процесса для отправки сообщения на сервер.
   * - processName
     - String
     - Имя процесса для отправки сообщения на сервер.
   * - socketBufferSize
     - int
     - Размер буфера сокета в байтах.
   * - soTimeout
     - int
     - Таймаут блокировки чтения через сокет в миллисекундах (0 - таймаут по умолчанию в ОС).
   * - connectTimeout
     - int
     - Таймаут подключения к сокету в миллисекундах (0 - таймаут по умолчанию в ОС)
   * - wireCrypt
     - String or WireCrypt
     - Уровень шифрования сетевого трафика (``DISABLED``, ``ENABLED``, ``REQUIRED``, ``DEFAULT``). В ``Jaybird 3.0.4+`` и ``Jaybird 4`` свойство имеет тип ``WireCrypt``. В ``Jaybird 5`` свойство имеет тип ``String``.
   * - wireCryptAsEnum
     - WireCrypt
     - Альтернатива ``wireCrypt``.
   * - dbCryptConfig
     - String
     - Настройки шифрования базы данных.
   * - wireCompression
     - boolean
     - Сжатие сетевого трафика (требуется ``Firebird 3.0`` или выше). По умолчанию установлено значение ``false``.
   * - logger
     - java.io.OutputStream
     - Поток, в котором будет записываться вывод удаленного сервиса.

Вызовы всех процедур ``Services API`` являются асинхронными. Клиентское приложение может запустить вызов, но нет никаких других способов узнать,
закончено ли его выполнение, кроме чтения вывода вызова сервиса - ``EOF`` означает, что выполнение завершено.

``FBServiceManager`` преобразует асинхронные вызовы в синхронные, постоянно запрашивая выходной поток сервиса.
Если указано свойство ``logger``, то полученные данные копируются в указанный ``OutputStream``, в противном случае они просто игнорируются и отслеживается ``EOF-маркер``.

Это поведение можно изменить, переопределив соответствующий метод в классе ``FBServiceManager`` и/или подклассах.
Единственное требование - отсоединяться от менеджера сервисов, когда он больше не нужен.

Создение резервной копии и восстановление из неё
----------------------------------------------------

``Jaybird`` поддерживает ``gbak``, ``gbak``, а также резервное копирование и восстановление с помощью ``nbackup``.

Резервное копирование и восстановление с помощью gbak
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Процедуры резервного копирования и восстановления ``gbak`` определены в интерфейсе ``BackupManager`` и реализованы в классе ``FBBackupManager``.
Этот класс обеспечивает резервное копирование ``gbak`` на стороне сервера.
Для получения подробной информации о самом ``gbak`` обратитесь к Руководству администратора.

Следующие методы используются для выполнения резервного копирования и восстановления:

.. tabularcolumns:: |>{\ttfamily\arraybackslash}\X{9}{30}|>{\ttfamily\arraybackslash}\X{5}{30}|>{\arraybackslash}\X{16}{30}|
.. list-table::
   :class: longtable
   :header-rows: 1

   * - Свойство
     - Тип
     - Описание
   * - database
     - String
     - Для резервного копирования указывается путь или псевдоним базы данных. Для восстановления указывается путь к базе данных, в которую будет восстановлена резервная копия. В случае, когда необходимо создать многофайловую базу данных, используйте метод ``addRestorePath(String, int)``.
   * - backupPath
     - String
     - Путь к файлу резервной копии. Для операции резервного копирования указывает путь и имя файла резервной копии. Если необходимо создать многофайловые файлы резервных копий, используйте метод ``addBackupPath(String, int)``. Для операции восстановления указывается путь к единственному файлу резервной копии. Если базу данных необходимо восстановить из многофайловой резервной копии, используйте метод ``addBackupPath(String)``.
   * - restorePageBufferCount
     - int
     - Количество страниц, которые будут кэшированы базы данных. Должно использоваться только для операции восстановления. Если не задано, используется размер страничного кэша, записанный в резервной копии.
   * - restorePageSize
     - int
     - Размер страницы базы данных. Должен использоваться только для операции восстановления. Допустимые значения зависят от версии ``Firebird``, но должно быть одним из 1024, 2048, 4096, 8192, 16384 или 32768. Если значение не задано, используется размер страницы, записанный в резервной копии.
   * - restoreReadOnly
     - boolean
     - Установите значение ``true``, если база данных должна быть восстановлена в режиме ``read-only``.
   * - restoreReplace
     - boolean
     - Установите значение ``true``, если восстановление должно заменить существующую базу данных на базу данных из резервной копии.
	   При невозможности восстановить резервную копию легко потерять существующую базу данных, поскольку сначала удаляется существующая база данных и только после этого начинается процесс восстановления. Чтобы избежать такой ситуации, рекомендуется сначала восстановить базу данных в какой-нибудь файл, а затем использовать команды файловой системы для замены существующей базы данных на вновь созданную.
   * - verbose
     - boolean
     - Подробная запись в журнал. У службы, вызываемой сервером, будет большой вывод, который будет записываться в поток вывода, указанный в свойстве ``logger``.

Следующие методы  используются при многофайловых операциях резервного копирования и восстановления:

.. tabularcolumns:: |>{\ttfamily\arraybackslash}\X{9}{25}|>{\arraybackslash}\X{16}{25}|
.. list-table::
   :class: longtable
   :header-rows: 1

   * - Метод
     - Описание
   * - addBackupPath(String)
     - Добавляет путь к файлу резервной копии из многофайловой резервной копии. Следует использовать только для операции восстановления.
   * - addBackupPath(String, int)
     - Добавляет путь к многофайловой резервной копии. Второй параметр задает максимальный размер файла в байтах. Используется только для резервного копирования.
   * - addRestorePath(String, int)
     - Добавляет путь для многофайловой базы данных. Второй параметр задает максимальный размер файла базы данных в страницах. Максимальный размер в байтах можно получить, умножив это значение на значение ``restorePageSize``.
   * - clearBackupPaths()
     - Удаляет все указанные пути к резервным копиям. Этот метод также удаляет путь, указанный в свойстве ``backupPath``.
   * - clearRestorePaths()
     - Удаляет все указанные пути к файлам восстановления. Этот метод также удаляет путь, указанный в свойстве ``database``.

Все указанные пути - это пути на удаленном сервере. У этого есть следующие последствия:

* невозможно выполнить резервное копирование на локальный или сетевой диск, если он не смонтирован на удаленном сервере;
* восстановление с локального или сетевого диска невозможно, если он не смонтирован на удаленном сервере.

Для выполнения удаленного резервного копирования и восстановления можно использовать ``FBStreamingBackupManager``.

После указания всех необходимых свойств можно использовать методы ``backupDatabase()``, ``backupMetadata()`` и ``restoreDatabase()``
для выполнения задач резервного копирования и восстановления. Эти методы будут блокироваться до завершения операции.
Если было установлено свойство ``logger``, то вывод службы будет записан в указанный поток вывода, в противном случае он будет проигнорирован.

Пример выполнения резервного копирования и восстановления:

.. code-block::

	// backup the database
	BackupManager backupManager = new FBBackupManager();

	backupManager.setServerName("localhost");
	backupManager.setPortNumber(3050);
	backupManager.setUser("SYSDBA");
	backupManager.setPassword("masterkey");
	backupManager.setLogger(System.out);
	backupManager.setVerbose(true);

	backupManager.setDatabase("C:/database/employee.fdb");
	backupManager.setBackupPath("C:/database/employee.fbk");

	backupManager.backupDatabase();
	...
	// and restore it back
	BackupManager restoreManager = new FBBackupManager();

	restoreManager.setServerName("localhost");
	restoreManager.setPortNumber(3050);
	restoreManager.setUser("SYSDBA");
	restoreManager.setPassword("masterkey");
	restoreManager.setLogger(System.out);
	restoreManager.setVerbose(true);

	restoreManager.setRestoreReplace(true); // attention!!!

	restoreManager.setDatabase("C:/database/employee.fdb");
	restoreManager.setBackupPath("C:/database/employee.fbk");

	backupManager.restoreDatabase();

Методы ``backupDatabase(int)`` и ``restoreDatabase(int)`` позволяют указать дополнительные параметры резервного копирования и восстановления,
которые нельзя определить через свойства этого класса. Значение параметра представляет собой побитовую комбинацию следующих констант:

.. tabularcolumns:: |>{\ttfamily\arraybackslash}\X{9}{25}|>{\arraybackslash}\X{16}{25}|
.. list-table::
   :class: longtable
   :header-rows: 1

   * - Константа
     - Описание
   * - BACKUP_CONVERT
     - Резервное копирование внешних файлов в виде таблиц. По умолчанию резервные копии внешних таблиц не создаются, в файле резервной копии сохраняются только ссылки на внешние файлы с данными. При использовании этого параметра резервная копия будет сохранять внешние таблицы так, как если бы они были обычными таблицами. При восстановлении таблицы будут созданы как обычные таблицы.
   * - BACKUP_EXPAND
     - Отключение сжатия данных. Утилита ``gbak`` использует ``RLE-сжатие`` для строк в файле резервной копии. При использовании этой опции строки будут записаны в полном объеме.
   * - BACKUP_IGNORE_CHECKSUMS
     - Игнорировать контрольные суммы. Утилита резервного копирования не может создать резервную копию базы данных с ошибками контрольных сумм страниц. Такая база данных считается поврежденной, полнота и корректность резервного копирования не гарантируется. Однако в некоторых случаях такие ошибки можно игнорировать, например, когда повреждена индексная страница. В этом случае данные будут в порядке, ошибка исчезнет при восстановлении базы данных и пересоздании индекса. Используйте этот параметр только в тех случаях, когда обнаружены ошибки контрольной суммы, которые невозможно исправить без полного цикла резервного копирования/восстановления. Убедитесь, что восстановленная база содержит корректные данные.
   * - BACKUP_IGNORE_LIMBO
     - Игнорировать транзакции ``in-limbo``. Утилита резервного копирования не может создать резервную копию базы данных с транзакциями ``in-limbo``. При возникновении такой ситуации резервное копирование должно дождаться решения об исходе ``in-limbo`` транзакции. По истечении времени ожидания будет получено исключение, и резервное копирование будет прервано. Данная опция позволяет обойти эту ситуацию - ``gbak`` ищет последнюю зафиксированную версию записи и записывает ее в резервную копию.
   * - BACKUP_METADATA_ONLY
     - Резервное копирование только метаданных. При указании этого параметра создается резервная копия только информации о метаданных (структуры таблиц и/или представлений, хранимых процедур и т. д.), но данные не резервируются. Это позволяет восстановить чистую базу данных из резервной копии.
   * - BACKUP_NO_GARBAGE_COLLECT
     - Не выполнять сборку мусора во время резервного копирования. Процесс резервного копирования читает все записи в таблицах по очереди. Если включена принудительная сборка мусора, транзакция, которая обращается к последней версии записи, также маркирует предыдущие версии как мусор. Этот процесс занимает много времени и может быть отключен при создании резервной копии, где будет прочитана самая последняя версия. Позже оператор может восстановить базу данных из резервной копии. В базах данных с большим числом back-версий записей цикл резервного копирования-восстановления может быть быстрее, чем традиционная сборка мусора.
   * - BACKUP_NON_TRANSPORTABLE
     - Использовать непереносимый формат резервной копии. По умолчанию ``gbak`` создает переносимую резервную копию, для которой не имеет значения, будет она восстановлена на ``big-endian`` или ``little-endian`` платформе. При включении этой опции будет использоваться непереносимый формат, который позволяет восстанавливать базу данных только на той же архитектуре.
   * - RESTORE_DEACTIVATE_INDEX
     - Деактивировать индексы во время восстановления. По умолчанию индексы создаются в начале процесса восстановления, и они обновляются с каждой восстановленной записью. Для больших таблиц эффективнее сначала сохранить данные в базе, а затем обновить индексы. При указании этой опции индексы будут восстановлены в неактивном состоянии. После восстановления администратор базы данных должен активировать индексы самостоятельно.
   * - RESTORE_NO_SHADOW
     - Не восстанавливать теневую копию базу данных. Если настроена теневая копия базы данных, в файле резервной копии сохраняется абсолютный путь к ней. Если восстановить этот файл на другой системе, где такой путь не существует (например, при переносе базы данных из ``Windows`` в ``Linux`` или иным способом), восстановление будет завершено с ошибкой. Использование этой опции позволяет избежать подобной ситуации.
   * - RESTORE_NO_VALIDITY
     - Не восстанавливать ограничения столбцов. Этот параметр необходим, когда ограничения столбца (например, ``NOT NULL``) были добавлены после данных, но в базе данных остались записи, не удовлетворяющие этим ограничениям.
   * - RESTORE_ONE_AT_A_TIME
     - Выполнять фиксацию изменений после восстановления каждой таблицы. По умолчанию все данные восстанавливаются в одной транзакции. Если по каким-то причинам полное восстановление невозможно, использование этой опции позволит восстановить хотя бы часть данных.
   * - RESTORE_USE_ALL_SPACE
     - Не резервировать ``20%`` на каждой странице для будущих версий. Полезно для баз данных, доступных только для чтения.

Пример использования дополнительных опций для восстановления из резервной копии:

.. code-block::

	BackupManager restoreManager = new FBBackupManager();

	restoreManager.setServerName("localhost");
	restoreManager.setPortNumber(3050);
	restoreManager.setUser("SYSDBA");
	restoreManager.setPassword("masterkey");
	restoreManager.setLogger(System.out);
	restoreManager.setVerbose(true);

	restoreManager.setRestoreReplace(true); // attention!!!

	restoreManager.setDatabase("C:/database/employee.fdb");
	restoreManager.setBackupPath("C:/database/employee.fbk");

	// restore database with no indexes,
	// validity constraints and shadow database
	backupManager.restoreDatabase(
		BackupManager.RESTORE_DEACTIVATE_INDEX |
		BackupManager.RESTORE_NO_VALIDITY |
		BackupManager.RESTORE_NO_SHADOW |
		BackupManager.RESTORE_ONE_AT_A_TIME);

Потоковое резервное копирование и восстановление в gbak
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Класс ``FBStreamingBackupManager`` обеспечивает потоковое резервное копирование и восстановление.
Потоковое резервное копирование и восстановление позволяет осуществлять клиент-серверное резервное копирование и восстановление,
передавая резервную копию с сервера на клиент - при резервном копировании, или с клиента на сервер - при восстановлении.

Класс реализует интерфейс ``BackupManager``. Методы для указания файлов резервных копий (``setBackupPath``, ``addBackupPath``) не поддерживаются и выбрасывают исключение ``IllegalArgumentException``. Резервное копирование в режиме ``Verbose`` не поддерживается.

В классе определены следующие методы:

.. tabularcolumns:: |>{\ttfamily\arraybackslash}\X{10}{25}|>{\arraybackslash}\X{15}{25}|
.. list-table::
   :class: longtable
   :header-rows: 1

   * - Метод
     - Описание
   * - setBackupOutputStream(OutputStream)
     - Поток вывода для записи резервной копии.
   * - setRestoreInputStream(InputStream)
     - Поток ввода для чтения резервной копии для восстановления.
   * - setBackupBufferSize(int)
     - Размер локального буфера (в байтах), который будет использоваться при резервном копировании; по умолчанию - 30Кб.

Nbackup
~~~~~~~~~~

Интерфейс ``NBackupManager`` и его реализация ``FBNbackupManager`` обеспечивают резервное копирование и восстановление nbackup через ``API`` сервиса.
Эта форма резервного копирования и восстановления является серверной, то есть все пути находятся на сервере ``Firebird``.
Для получения информации о ``nbackup`` обратитесь к Руководству администратора.

Дополнительные свойства для резервного копирования и восстановления ``nbackup``:

.. tabularcolumns:: |>{\ttfamily\arraybackslash}\X{9}{30}|>{\ttfamily\arraybackslash}\X{5}{30}|>{\arraybackslash}\X{16}{30}|
.. list-table::
   :class: longtable
   :header-rows: 1

   * - Свойство
     - Тип
     - Описание
   * - database
     - String
     - Для операции резервного копирования указывается путь или псевдоним базы данных для резервного копирования. Для операции восстановления - путь к базе данных, в которую будет восстановлен файл резервной копии.
   * - backupFile
     - String
     - Путь к файлу резервной копии. Для операции резервного копирования определяет путь и имя файла резервной копии, созданной на сервере. Для операции восстановления определяет путь к файлу резервной копии. Если базу данных необходимо восстановить из многофайловой резервной копии, используйте метод ``addBackupFile(String)`` для добавления дополнительных файлов.
   * - backupLevel
     - int
     - Уровень резервного копирования. При уровне 0 выполняется полное резервное копирование. При уровне ``N`` с ``N > 1`` будут созданы резервные копии всех страниц данных, измененных с момента последнего резервного копирования уровня ``N - 1``. Значение по умолчанию равно 0, если ``backupGuid`` не задан.
   * - backupGuid
     - String
     - Устанавливает ``GUID`` предыдущей резервной копии (в ``Firebird 4.0`` или выше). При этом будут созданы резервные копии всех страниц данных, измененных с момента выполнения резервного копирования, определенного по ``GUID``. ``GUID`` заключается в скобки (``{ GUID }``).
   * - noDbTriggers
     - boolean
     - Отключение триггеров для операций ``nbackup``, которые подключаются к базе данных.
   * - inPlaceRestore
     - boolean
     - Включает восстановление на месте (в ``Firebird 4.0`` или выше). Это позволяет выполнять инкрементное восстановление.
   * - preserveSequence
     - boolean
     - Включает сохранение последовательности для восстановления или исправления (в ``Firebird 4.0`` или выше). Сохраняется существующий ``GUID`` и последовательность репликации исходной базы данных.
   * - cleanHistory
     - boolean
     - Включение удаления истории (в ``Firebird 4.0.3`` или выше). Также должно быть установлено одно из свойств ``keepRows`` или ``keepDays``. Если опция включена, то после выполнения резервного копирования старые записи из ``RDB$BACKUP_HISTORY`` будут удалены.
   * - keepDays
     - int
     - Количество дней для хранения истории резервного копирования, когда включена опция ``cleanHistory``.
   * - keepRows
     - int
     - Количество строк, включая резервную копию, для хранения истории резервного копирования, когда включена опция ``cleanHistory``.

Методы свойства для резервного копирования и восстановления ``nbackup``:

.. tabularcolumns:: |>{\ttfamily\arraybackslash}\X{10}{25}|>{\arraybackslash}\X{15}{25}|
.. list-table::
   :class: longtable
   :header-rows: 1

   * - Метод
     - Описание
   * - addBackupFile(String)
     - Добавляет путь к файлу резервной копии из многофайловой резервной копии. На практике ``setBackupFile`` выполняет те же действия, что и ``addBackupFile``. Для резервного копирования используется только первый указанный или добавленный файл. Для восстановления файлы должны располагаться в правильном порядке, чтобы образовать цепочку от резервной копии с уровнем 0 до самого высокого уровня или до копии с последним ``GUID``.
   * - clearBackupFiles()
     - Удаляет список файлов резервных копий.
   * - backupDatabase()
     - Выполнение резервного копирования.
   * - restoreDatabase()
     - Восстановление из резервной копии.
   * - fixupDatabase()
     - Разблокировка базы данных после самостоятельного восстановления из блокированной резервной копии. Так как копия блокированной базы данных является так же блокированной, поэтому не получится использовать копию как рабочую базу данных. Включите ``preserveSequence``, чтобы сохранить исходный ``GUID`` базы данных и последовательность репликации.

После указания всех необходимых параметров можно использовать методы ``backupDatabase()``, ``restoreDatabase()`` и ``fixupDatabase()``. Эти методы будут блокироваться до тех пор, пока операция не будет завершена.

Пример выполнения процесса резервного копирования и восстановления ``nbackup``:

.. code-block::

	NBackupManager backupManager = new FBNBackupManager();

	backupManager.setServerName("localhost");
	backupManager.setPortNumber(3050);
	backupManager.setUser("SYSDBA");
	backupManager.setPassword("masterkey");

	// backup level 1 increment against a previously performed level 0
	backupManager.setDatabase("/path/to/database.fdb");
	backupManager.setBackupFile("/path/to/backup_lvl_1.nbk");
	backupManager.setBackupLevel(1);
	backupManager.backupDatabase();

	// restore level 0 and level 1 in new db restored.fdb
	backupManager.clearBackupFiles();
	backupManager.setDatabase("/path/to/restored.fdb");
	backupManager.addBackupFile("/path/to/backup_lvl_0.nbk");
	backupManager.addBackupFile("/path/to/backup_lvl_1.nbk");
	backupManager.restoreDatabase();

Обслуживание базы данных
---------------------------

В этой главе описаны методы интерфейса ``MaintenanceManager``, и его реализация - класс ``FBMaintenanceManager``.

Остановка и перезапуск базы данных
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Одной из наиболее часто используемых операций по обслуживанию базы данных является её остановка и/или возвращение ее в рабочее состояние.
Когда база данных остановлена, только пользователь, инициировавший остановку, ``SYSDBA`` или владелец базы данных,
может подключиться к базе данных и выполнять другие задачи, например, изменение метаданных или проверку и восстановление базы данных.

Остановка базы данных выполняется методом ``shutdownDatabase(int, int)``. Первый параметр - режим остановки, второй - максимально допустимое время работы до остановки.

Режимы остановки базы данных:

* ``SHUTDOWN_ATTACH`` - В этом режиме невозможно установить новое соединение с базой данных, но открытые соединения остаются работоспособными. Если по истечении указанного времени работы  до остановки все еще остаются открытые соединения, процесс остановки отменяется.
* ``SHUTDOWN_TRANSACTIONAL`` - В этом режиме невозможно запустить новые транзакции или открыть новые соединения с базой данных. Транзакции, которые были запущены на момент начала отключения остаются активными. Если запущенных транзакций нет, открытые в данный момент соединения можно отключить. Если по истечении указанного времени работы до остановки транзакции все еще выполняются, процесс остановки отменяется.
* ``SHUTDOWN_FORCE`` - Запускает процесс выключения, который будет завершен до истечения максимально допустимого времени работы. Во время ожидания новые соединения и транзакции не запрещены. По истечении таймаута любая запущенная транзакция не сможет зафиксироваться.

После остановки базы данных её владелец или ``SYSDBA`` может подключиться к ней и выполнить задачи обслуживания,
например, миграцию, проверку базы данных, изменение конфигурационных файлов.

Настройка теневой копии
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Тень базы данных - это синхронизированная копия базы данных, которая обычно хранится отдельно и может быть использована в качестве основной базы данных в случае сбоя основного сервера базы данных.
Теневые копии можно создать с помощью ``SQL-команды`` ``CREATE SHADOW`` и характеризуются параметром ``mode``:

* В режиме ``AUTO`` база данных продолжает работать, даже если тень становится недоступной;
* в режиме ``MANUAL`` все операции с базой данных приостанавливаютсяя, пока администратор базы данных не отменит процесс копирования данных в эту оперативную копию. Для этого, как минимум, он должен удалить оперативную копию, используя оператор ``DROP SHADOW``, и, при необходимости, создать новую оперативную копию с использованием оператора ``CREATE SHADOW``.

``MaintenanceManager`` предоставляет метод ``killUnavailableShadows()`` для удаления недоступных теней. Это эквивалентно команде ``gfix -kill``.

Если основная база данных становится недоступной, администратор может принять решение о переключении на теневую базу данных.
В этом случае тень должна быть активирована перед использованием. Для активации используется метод ``activateShadowFile()``.

В этом случае свойство ``database`` для ``MaintenanceManager`` должно указывать на файл теневой копии,
который должен быть расположен в локальной файловой системе сервера, к которому подключен класс управления.

Проверка и исправление баз данных
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Сервер ``Firebird`` делает все возможное, чтобы сохранить целостность базы данных. Это достигается с помощью алгоритма осторожной записи,
который обеспечивает запись данных таким образом, что, несмотря на падение сервера, файл базы данных всегда остается в целостности.
К сожалению, при определенных условиях, например, при сбое файловой системы или аппаратном отказе,
файл базы данных может повредиться. Сервер ``Firebird`` может обнаружить следующие повреждения:

* Пустые траницы. Это страницы базы данных, которые были выделены для последующей записи, но из-за сбоя не были использованы. Такие страницы необходимо пометить как неиспользуемые, чтобы освободить место в памяти;
* Поврежденные страницы. Это страницы базы данных, которые были повреждены в результате сбоев операционной системы или аппаратного обеспечения.

Класс ``MaintenanceManager`` предоставляет метод ``validateDatabase()`` для выполнения проверки состояния базы данных и освобождения пустых страниц, если это необходимо.
Он также сообщает о наличии ошибок контрольной суммы. Результаты работы записываются в выходной поток, настроенный в свойстве ``logger``.

Метод ``validateDatabase(int)`` можно использовать для настройки процесса проверки:

* ``VALIDATE_READ_ONLY`` - Выполняет проверку в режиме только для чтения. В этом случае файл базы данных не будет исправлен, будет сообщено только о наличии ошибок. Можно использовать для регулярной проверки состояния базы данных.
* ``VALIDATE_FULL`` - Выполняет полную проверку структур записей и страниц, освобождая незадействованные фрагменты записей.
* ``VALIDATE_IGNORE_CHECKSUM`` - Игнорирует контрольные суммы во время восстановления. Ошибка контрольной суммы означает, что страница базы данных была перезаписана в случайном порядке и данные, хранящиеся на ней, повреждены. При указании этого параметра процесс проверки будет успешным, даже если присутствуют ошибки контрольных сумм.

Для восстановления поврежденной базы данных используется метод ``markCorruptRecords()``, который помечает поврежденные записи как недоступные.
Этот метод эквивалентен команде ``gfix -mend``. После этой операции можно создать резервную копию базы данных и восстановить ее в другом месте.

.. warning::

	Наличие ошибок контрольной суммы и последующее использование метода ``markCorruptedRecords()`` пометит все поврежденные данные как неиспользуемые.
	Чтобы оценить повреждения, необходимо выполнить тщательную проверку после цикла резервного копирования/восстановления.

Управление limbo транзакциями
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Лимбо-транзакции - это транзакции, которые были подготовлены к фиксации, но так и не были зафиксированы.
Это может произойти, например, когда к базе данных обращались приложения с поддержкой ``JTA`` из ``Java``.
Транзакции ``in-limbo`` влияют на нормальную работу базы данных, поскольку записи, которые были изменены в этих транзакциях, недоступны.
Также транзакции ``in-limbo`` мешают сборке мусора, поскольку сборщик не знает, может ли он отбросить версии записей в зависшей транзакции.

``Jaybird`` содержит функции, позволяющие восстановить транзакции ``in-limbo`` и либо фиксировать их, либо откатывать.
``MaintenanceManager`` предоставляет следующие методы для выполнения этой операции в интерактивном режиме:

.. tabularcolumns:: |>{\ttfamily\arraybackslash}\X{10}{25}|>{\arraybackslash}\X{15}{25}|
.. list-table::
   :class: longtable
   :header-rows: 1

   * - Метод
     - Описание
   * - listLimboTransactions()
     - Метод выводит идентификаторы всех транзакций ``in-limbo`` в выходной поток, указанный в свойстве ``logger``. Приложение должно либо автоматически обработать вывод для отката или фиксации изменений, либо либо представить вывод пользователю, чтобы он принял решение.  качестве альтернативы можно использовать два следующих метода.
   * - limboTransactionsAsList()
     - Возвращает ``List<Long>`` из идентификаторов всех транзакций ``in-limbo``.
   * - getLimboTransactions()
     - Возвращает массив ``long`` с идентификаторами всех транзакций ``in-limbo``.
   * - commitTransaction(long)
     - Фиксирует транзакцию с указанным идентификатором.
   * - rollbackTransaction(long)
     - Откатывает транзакцию с указанным идентификатором.

Очистка базы данных
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Транзакции ``in-limbo`` - не единственный тип транзакций, препятствующих сборке мусора.
Другой тип - это транзакции, которые завершились откатом, но сделанные в них изменения не были автоматически отменены.
Такие транзакции помечаются как транзакции «rollback» на странице инвентаризации транзакций, и это препятствует продвижению
``OIT`` - идентификатора самой старой транзакции, создавшей версии записей, которые имеют отношение к любой из текущих транзакций.
При каждом обращении к записям ``Firebird`` приходится проверять все версии между текущей транзакцией и ``OIT``, что приводит к снижению производительности.
Для решения этой проблемы ``Firebird`` регулярно выполняет очистку базы данных, при которой обходит все записи базы данных,
удаляет изменения, внесенные откаченными транзакциями, и обновляет ``OIT``.

Процесс очистки контролируется разницей между следующей транзакцией и ``OIT``, по умолчанию очистка выполняется при разнице 20000.
Это значение можно изменить. Также можно запустить процесс очистки вручную, независимо от текущей разницы между ``Next Transaction`` и ``OIT``.

``MaintenanceManager`` предоставляет следующие методы для очистки базы данных:

.. tabularcolumns:: |>{\ttfamily\arraybackslash}\X{10}{25}|>{\arraybackslash}\X{15}{25}|
.. list-table::
   :class: longtable
   :header-rows: 1

   * - Метод
     - Описание
   * - setSweepThreshold(int)
     - Разница между ``Next Transaction`` и ``OIT``, при которой будет выполняться автоматическая очистка базы данных.
   * - sweepDatabase()
     - Принудительное выполнение очистки независимо от текущей разницы между ``Next Transaction`` и ``OIT``.

Другие свойства базы данных
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Другие свойства базы данных, которые можно настроить с помощью ``MaintenanceManager``:

.. tabularcolumns:: |>{\ttfamily\arraybackslash}\X{10}{25}|>{\arraybackslash}\X{15}{25}|
.. list-table::
   :class: longtable
   :header-rows: 1

   * - Метод
     - Описание
   * - setDatabaseAccessMode(int)
     - Изменение режима доступа к базе данных. Возможные значения:

		* ``ACCESS_MODE_READ_ONLY`` - делает базу данных доступной только для чтения;
		* ``ACCESS_MODE_READ_WRITE`` - делает базу данных доступной для чтения и записи.

   * - setDatabaseDialect(int)
     - Изменение диалекта SQL базы данных. Допустимы значения 1 и 3.
   * - setDefaultCacheBuffer(int)
     - Изменение количества страниц базы данных для кэширования. Параметр настраивается для каждой базы данных отдельно.
   * - setForcedWrites(boolean)
     - Изменение режима записи на диск.
   * - setPageFill(int)
     - Определение процента заполнения страницы. ``Firebird`` оставляет ``20%`` свободного места на каждой странице базы данных для будущих версий записей. Можно указать ``Firebird`` не резервировать место. Возможные значения:

		* ``PAGE_FILL_FULL`` - не резервировать место для будущих версий;
		* ``PAGE_FILL_RESERVE`` - резервировать свободное место для будущих версий записей.

Табличная статистика соединения
---------------------------------

В ``Jaybird 5`` добавлен новый класс, ``org.firebirdsql.management.FBTableStatisticsManager``, который можно использовать для получения табличной статистики соединения.

Создайте экземпляр с помощью ``FBTableStatisticsManager#of(java.sql.Connection)`` - соединение должно быть развернуто в ``FirebirdConnection`` -
и получите снимок статистики с помощью ``FBTableStatisticsManager#getTableStatistics()``.

.. note::

	Это экспериментальная функция. Ее API может измениться в последующих выпусках. Она может быть удалена или полностью заменена в будущем.

Статистика базы данных
-------------------------

Интерфейс ``StatisticsManager`` и соответствующая реализация в классе ``FBStatisticsManager`` позволяют получить статистическую информацию по базе данных.

Следующие методы предоставляют функции, эквивалентные утилите ``gstat``. Вывод записывается в выходной поток, указанный в свойстве ``logger``.

.. tabularcolumns:: |>{\ttfamily\arraybackslash}\X{10}{25}|>{\arraybackslash}\X{15}{25}|
.. list-table::
   :class: longtable
   :header-rows: 1

   * - Метод
     - Описание
   * - getDatabaseStatistics()
     - Полной статистика по базе данных.
   * - getDatabaseStatistics(int)
     - Статистика для указанных опций. Возможные значения (битовая маска, можно комбинировать):

		* ``DATA_TABLE_STATISTICS``
		* ``SYSTEM_TABLE_STATISTICS``
		* ``INDEX_STATISTICS``
		* ``RECORD_VERSION_STATISTICS``

   * - getHeaderPage()
     - Информацию из заголовочной страницы.
   * - getTableStatistics(String[])
     - Статистика по указанным таблицам.
