Работа с событиями
========================

``Firebird`` поддерживает события. Событие - это функция, которая обеспечивает асинхронное уведомление подключенных приложений о событиях, 
инициированных базой данных или другими приложениями.
Вместо того, чтобы требовать от приложений перечитывания таблиц базы данных для проверки изменений, 
события позволяют этого избежать: триггеры в базе данных могут отправлять событие в случае изменения. 
Более того, событие может быть настолько специфичным, что приложению потребуется перечитать только ограниченный набор записей, возможно, только одну.


В этой главе описывается механизм событий в ``Firebird`` и распространенные сценарии его использования.

События базы данных
------------------------

Событие - это сообщение, сгенерированное в триггере, хранимой процедуре или блоке выполнения, которое доставляется подписанным на события приложениям.

Событие характеризуется только именем, которое используется при публикации события, поэтому два разных события должны иметь два разных имени.
Приложения, подписывающиеся на события, должны указывать имена интересующих событий, подстановочные знаки не допускаются.
Приложения либо предоставляют функцию обратного вызова, которая будет вызываться в случае возникновения события, либо должны периодически опрашивать публикуемые события.

События поступают приложению только после фиксации транзакции, вызвавшей событие.
Время передачи событий зависит от нагрузки на сервер, нагрузки на приложение, сетевых задержек между приложением и системой базы данных.
Может случиться и так, что несколько транзакций будут зафиксированы до того, как события будут доставлены клиенту.
Но и в этом случае функция обратного вызова будет вызвана только один раз, а в качестве параметров будут переданы имя события и количество событий.
То же самое относится и к периодическому запросу, приложение получит имена событий и их количество с момента последнего запроса.

``Firebird`` хранит информацию о подписках в таблице, где столбцы содержат названия событий, строки соответствуют подписанным приложениям,
а ячейки содержат количество событий для конкретного приложения.
Когда событие публикуется, ``Firebird`` проверяет информацию о подписке и увеличивает счетчик событий для подписанных приложений.
Другой поток периодически проверяет таблицу и уведомляет приложение обо всех новых событиях.
Такой механизм позволяет сохранять таблицу уведомлений небольшой и сократить количество сообщений, отправляемых приложению.

Передача параметров вместе с событием, например, идентификатора измененных записей, невозможна.
Также невозможно указывать такую информацию в именах событий, подстановочные знаки не поддерживаются.
В таких случаях приложения должны вести таблицу отслеживания изменений, в которой хранятся идентификаторы измененных записей,
а механизм событий использовать для сообщения приложению о том, что в таблицу были добавлены новые записи.

Публикация событий
------------------------

События публикуются из кода ``PSQL`` (триггера, хранимой процедуры, выполняемого блока, функции) с помощью команды ``POST_EVENT``.
Можно создать хранимую процедуру с единственной целью - публиковать события:

Пример публикации событий из кода ``PSQL``:

.. code-block::

	CREATE PROCEDURE sp_post_event(event_name VARCHAR(72))
	AS BEGIN
		POST_EVENT :event_name;
	END

Оператор ``EXECUTE BLOCK`` можно использовать для выполнения операторов ``PSQL`` в коде ``DSQL``.
Использование ``EXECUTE BLOCK`` для публикации событий:

.. code-block::

	try (Statement stmt = connection.createStatement()) {
		stmt.execute(
			"EXECUTE BLOCK AS BEGIN POST_EVENT 'some_evt'; END");
	} finally {
		stmt.close();
	}

Подписка на события
------------------------

Структура классов и интерфейсов пакета ``org.firebirdsql.event`` аналогична  ``Services API``.
Есть центральный класс управления, который устанавливает соединение с базой данных и предоставляет сервисные методы для работы с событиями,
интерфейс обратного вызова, который приложения должны реализовать для использования асинхронного уведомления о событиях, и интерфейс,
представляющий событие базы данных с двумя свойствами, именем события и количеством вхождений.

Перед началом использования ``EventManager`` нужно настроить следующие параметры:

.. tabularcolumns:: |>{\ttfamily\arraybackslash}\X{6}{30}|>{\ttfamily\arraybackslash}\X{8}{30}|>{\arraybackslash}\X{16}{30}|
.. list-table:: Параметры EventManager
   :class: longtable
   :header-rows: 1

   * - Свойство
     - Тип
     - Описание
   * - host

       serverName
     - String
     - Имя или ``IP-адрес`` узла, к которому будет отправлен запрос. Обязательный параметр.
   * - port

       portNumber
     - int
     - Порт, на который отправляется запрос, по умолчанию 3050.
   * - database
     - String
     - Путь к базе данных. Значение свойства зависит от вызываемой службы и будет описано в каждом из разделов ниже.
   * - user
     - String
     - Пользователь, от имени которого будут выполняться все вызовы. Обязательный параметр.
   * - password
     - String
     - Пароль, соответствующий указанному пользователю. Обязательный параметр.
   * - roleName
     - String
     - Роль. Необязательный параметр.
   * - expectedDb
     - String
     - В ``Firebird 3.0`` и выше это значение используется для поиска базы данных безопасности не по умолчанию, которую следует использовать при аутентификации. Значение - это путь к базе данных или псевдоним. Необязательный параметр.
   * - authPlugins
     - String
     - Список плагинов аутентификации, которые необходимо использовать (игнорируется для ``Firebird 2.5`` или более ранних версий). Необязательный параметр.
   * - processId
     - int
     - Идентификатор процесса для отправки сообщения на сервер.
   * - processName
     - String
     - Имя процесса для отправки сообщения на сервер.
   * - socketBufferSize
     - int
     - Размер буфера сокета в байтах.
   * - soTimeout
     - int
     - Таймаут блокировки чтения через сокет в миллисекундах (0 - таймаут по умолчанию в ОС).
   * - connectTimeout
     - int
     - Таймаут подключения к сокету в миллисекундах (0 - таймаут по умолчанию в ОС)
   * - wireCrypt
     - String or WireCrypt
     - Уровень шифрования сетевого трафика (``DISABLED``, ``ENABLED``, ``REQUIRED``, ``DEFAULT``). В ``Jaybird 3.0.4+`` и ``Jaybird 4`` свойство имеет тип ``WireCrypt``. В ``Jaybird 5`` свойство имеет тип ``String``.
   * - wireCryptAsEnum
     - WireCrypt
     - Альтернатива ``wireCrypt``.
   * - dbCryptConfig
     - String
     - Настройки шифрования базы данных. Подробнее см. :ref:`dbCryptConfig`.
   * - wireCompression
     - boolean
     - Сжатие сетевого трафика (требуется ``Firebird 3.0`` или выше). По умолчанию установлено значение ``false``.

После настройки этих свойств нужно вызвать метод ``connect()``, чтобы установить физическое соединение с базой данных.
На этом этапе ``EventManager`` готов к приему уведомлений о событиях.

Можно использовать асинхронное уведомление о событиях или использовать методы, 
которые будут блокироваться до тех пор, пока событие не будет доставлено или не истечет время ожидания.

Асинхронное уведомление о событиях
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Асинхронное уведомление о событиях использует отдельный поток демона для ожидания уведомлений о событиях и доставки их зарегистрированным слушателям.
Слушатели добавляются с помощью метода ``addEventListener(String, EventListener)``, где первый параметр содержит имя события, на которое нужно подписаться,
а второй - экземпляр интерфейса ``EventListener``, который будет получать уведомления о наступлении этого события.
Допускается использование одного и того же экземпляра интерфейса ``EventListener`` для прослушивания разных событий.

Пример регистрации слушателя событий для асинхронного уведомления о событиях:

.. code-block::

	var eventManager = new FBEventManager();
	eventManager.setServerName("localhost");
	eventManager.setUser("SYSDBA");
	eventManager.setPassword("masterkey");
	eventManager.setDatabaseName("c:/database/employee.fdb");

	eventManager.connect();

	eventManager.addEventListener("test_event",
    	event ->
        	System.out.printf("Event [%s] occured %d time(s)%n",
            	event.getEventName(), event.getEventCount()));

Использование блокирующих методов
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Можно использовать синхронные методы, один из которых блокирует выполнение до получения указанного события - метод ``waitForEvent(String)``, 
или один, который будет блокировать выполнение до получения указанного события или до истечения времени ожидание, 
указанного во втором параметре - метод ``waitForEvent(String, int)``.

Пример использования блокирующих методов:

.. code-block::

	EventManager eventManager = new FBEventManager();

	eventManager.setServerName("localhost");
	eventManager.setUser("SYSDBA");
	eventManager.setPassword("masterkey");
	eventManager.setDatabaseName("c:/database/employee.fdb");

	eventManager.connect();

	int eventCount =
		eventManager.waitForEvent("test_event", 10 * 1000);

	System.out.println(
		"Received " + eventCount + " event(s) during 10 sec.");

