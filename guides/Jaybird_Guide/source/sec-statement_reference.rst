Информация для работы с операторами
========================================

Получение сгенерированных ключей
-------------------------------------

``Jaybird`` предоставляет функцию ``getGeneratedKeys()`` для ``Statement`` и ``PreparedStatement``. 
Она может быть использована для получения сгенерированных идентификаторов (и других столбцов) из ``DML-запросов``.

Функция доступна для ``Connection.prepareStatement``, ``Statement.execute``, ``Statement.executeUpdate`` и ``Statement.executeLargeUpdate``.

Существует четыре сценария использования:

* Методы, принимающие параметр ``int`` со значениями ``Statement.NO_GENERATED_KEYS`` и ``Statement.RETURN_GENERATED_KEYS``. См. подробнее в разделе `Базовое извлечение сгенерированных ключей`_.
* Методы, принимающие параметр ``int[]`` с индексами столбцов. См. подробнее в разделе `Сгенерированные ключи по индексу столбца`_.
* Методы, принимающие параметр ``String[]`` с именами столбцов. См. подробнее в разделе `Сгенерированные ключи по имени столбца`_.
* Предоставление запроса, уже содержащего предложение ``RETURNING``, для любого из этих методов. В этом случае все предыдущие случаи игнорируются, и запрос выполняется как есть. Результат можно получить с помощью функции ``getGeneratedKeys()``.

Эта функция доступна для ``INSERT``, ``UPDATE``, ``UPDATE OR INSERT`` и ``DELETE``, а также для ``MERGE``.

При извлечении сгенерированных ключей в оператор добавляется предложение ``RETURNING``. 
``Firebird 4.0`` и более ранние версии поддерживают RETURNING только для операций ``DML``, изменяющих одну строку. 
Попытка использовать функцию ``getGeneratedKeys()`` в операциях, затрагивающих несколько строк, приведет к ошибке ``«multiple rows in singleton select»``.
Поддержка многострочного RETURNING доступна начиная с ``Jaybird 5``.

В примерах, приведенных в этом разделе, используется следующая (``Firebird 3.0``) таблица:

.. code-block::

    create table PERSON (
        ID integer generated by default as identity constraint pk_employee primary key,
        FIRSTNAME varchar(20),
        LASTNAME varchar(20),
        BIRTHDATE date,
        "age" integer generated always as (datediff(year, birthdate, current_date))
    )

Базовое извлечение сгенерированных ключей
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Эта форма получения сгенерированных ключей включает в себя следующие методы:

* ``Connection.prepareStatement(String sql, int autoGeneratedKeys)``
* ``Statement.execute(String sql, int autoGeneratedKeys)``
* ``Statement.executeUpdate(String sql, int autoGeneratedKeys)``
* ``Statement.executeLargeUpdate(String sql, int autoGeneratedKeys)``

Если передается ``NO_GENERATED_KEYS``, запрос будет выполнен как обычный запрос.

При использовании ``RETURN_GENERATED_KEYS`` драйвер вернет все столбцы таблицы в виде сгенерированных ключей. 
Столбцы упорядочены по порядковому номеру (как указано в метаданных ``JDBC`` таблицы). 
Рекомендуется извлекать значения из набора результатов ``getGeneratedKeys()`` по имени столбца.

Не следует передавать ``NO_GENERATED_KEYS`` в фиксированном виде. 
Лучше использовать эквивалентный метод ``prepareStatement`` или ``executeXXX``, который принимает только строку. 
Использование значения ``NO_GENERATED_KEYS`` имеет смысл только в коде, который динамически принимает решение между ``NO_GENERATED_KEYS`` и ``RETURN_GENERATED_KEYS``.

Пример использования RETURN_GENERATED_KEYS
""""""""""""""""""""""""""""""""""""""""""""""""

Ниже приводится добавление записи в таблицу ``PERSON`` с помощью ``Statement`` и получение сгенерированного идентификатора с помощью ``Statement.RETURN_GENERATED_KEYS``:

.. code-block::

    Connection connection = ...;
    try (Statement statement = connection.createStatement()) {
        statement.executeUpdate(
            "insert into person(firstname, lastname, birthdate) "
                + "values ('Mark', 'Rotteveel', date'1979-01-12')",
            Statement.RETURN_GENERATED_KEYS); -- 1             

    try (ResultSet keys = statement.getGeneratedKeys()) { -- 2
        if (keys.next()) { -- 3                                  
            int generatedId = keys.getInt("id"); -- 4             
            int age = keys.getInt("age"); -- 5                     
            String firstName = keys.getString("firstname"); -- 6

            System.out.printf("Inserted: %s, Id: %d, Age: %d%n",
                firstName, generatedId, age);
            }
        }
    }

Описание ключевых моментов, примеденных в примере:

1. Использование ``Statement.RETURN_GENERATED_KEYS`` указывает ``Jaybird`` разобрать оператор и добавить предложение ``RETURNING`` со всеми столбцами таблицы ``PERSON``.
2. Получение результирующего набора сгенерированных ключей из оператора.
3. Как и обычный результирующий набор, он располагается перед первой строкой, поэтому необходимо вызвать ``next()``.
4. Сгенерированное значение столбца ``ID``.
5. Вычисленное значение столбца ``AGE``.
6. Результаты сгенерированных ключей также содержат обычные столбцы, такие как ``FIRSTNAME``.

Пример подготовленного оператора, генерирующего извлечение ключей:

.. code-block::

    try (PreparedStatement statement = connection.prepareStatement(
            "insert into person(firstname, lastname, birthdate) values (?, ?, ?)",
            Statement.RETURN_GENERATED_KEYS)) {            
        statement.setString(1, "Mark");
        statement.setString(2, "Rotteveel");
        statement.setObject(3, LocalDate.of(1979, 1, 12));

        statement.executeUpdate();
        try (ResultSet keys = statement.getGeneratedKeys()) { 
            if (keys.next()) {                                  
                int generatedId = keys.getInt("id");              
                int age = keys.getInt("age");                     
                String firstName = keys.getString("firstname");

                System.out.printf("Inserted: %s, Id: %d, Age: %d%n",
                    firstName, generatedId, age);
            }
        }
    }


Кроме использования параметров, отличие заключается в том, что использование ``Statement.RETURN_GENERATED_KEYS`` перешло из режима выполнения в режим подготовки. 
Это имеет смысл, если учесть, что после подготовки оператор можно использовать повторно.

Сгенерированные ключи по индексу столбца
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Эта форма получения сгенерированных ключей включает следующие методы:

* ``Connection.prepareStatement(String sql, int[] columnIndexes)``
* ``Statement.execute(String sql, int[] columnIndexes)``
* ``Statement.executeUpdate(String sql, int[] columnIndexes)``
* ``Statement.executeLargeUpdate(String sql, int[] columnIndexes)``

Значения в параметре ``int[]`` - это порядковые номера столбцов, указанные в метаданных таблицы (``JDBC``).

.. warning::

    В ``Jaybird 3`` и более ранних версиях массив null или пустой массив молча игнорировался, и оператор выполнялся нормально (не создавая сгенерированных ключей). 
    В ``Jaybird 4`` это поведение изменилось, и вместо этого будет выброшено исключение с сообщением ``«Generated keys array columnIndexes was empty or null. A non-empty array is required»``.

    В ``Jaybird 3`` и более ранних версиях недопустимые порядковые номера игнорируются и молча отбрасываются: при передаче ``new int[] { 1, 5, 6 }`` все будет работать, даже если нет шестого столбца. В Jaybird 4 это поведение изменилось, и вместо этого будет выброшено исключение с сообщением ``«Generated keys column position <position> does not exist for table <tablename>. Check DatabaseMetaData.getColumns (column ORDINAL_POSITION) for valid values»``.

Пример использования индексов столбцов
"""""""""""""""""""""""""""""""""""""""""""

При извлечении по индексу столбца используется порядковый номер, указанный в ``DatabaseMetaData.getColumns``, столбец ``ORDINAL_POSITION``. 
На практике это значение ``RDB$RELATION_FIELDS.RDB$FIELD_POSITION + 1`` для данного столбца.

В примере столбцами являются:

1. ``ID``
2. ``FIRSTNAME``
3. ``LASTNAME``
4. ``BIRTHDATE``
5. ``AGE``

Получение ключей по индексу в подготовленном операторе:

.. code-block::

    try (PreparedStatement statement = connection.prepareStatement(
            "insert into person(firstname, lastname, birthdate) values (?, ?, ?)",
            new int[] { 1, 5 })) { -- 1                         
    statement.setString(1, "Mark");
    statement.setString(2, "Rotteveel");
    statement.setObject(3, LocalDate.of(1979, 1, 12));

    statement.executeUpdate();
        try (ResultSet keys = statement.getGeneratedKeys()) {
            if (keys.next()) {
            int generatedId = keys.getInt("id"); -- 2              
            int age = keys.getInt(2); -- 3                         

            System.out.printf("Id: %d, Age: %d%n",
                generatedId, age);
            }
        }
    }

1. Вместо ``Statement.RETURN_GENERATED_KEYS`` индексы столбцов передаются в виде массива, в данном случае 1 для ``ID`` и 5 для ``Age``.
2. Получение ``ID`` по имени.
3. Получение столбца ``age`` по позиции в результате. Индекс, используемый для извлечения, не совпадает с позицией столбца в таблице (5), переданной в ``prepare``. Поскольку это второй столбец в результирующем наборе, он извлекается по номеру 2.

.. warning::

    В ``Jaybird 3`` и более ранних версиях массив индексов перед использованием сортируется по возрастанию: 
    при передаче ``new int[] { 4, 1, 3 }`` колонки будут расположены в порядке ``ID``, ``LASTNAME``, ``BIRTHDATE``. 
    В ``Jaybird 4`` эта сортировка больше не применяется, поэтому столбцы будут располагаться в порядке, заданном массивом: ``BIRTHDATE``, ``ID``, ``LASTNAME``. 
    Чтобы избежать проблем, рекомендуется указывать столбцы в порядке возрастания или всегда извлекать их по имени.


Сгенерированные ключи по имени столбца
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Эта форма получения сгенерированных ключей включает в себя следующие методы:

* ``Connection.prepareStatement(String sql, String[] columnNames)``
* ``Statement.execute(String sql, String[] columnNames)``
* ``Statement.executeUpdate(String sql, String[] columnNames)``
* ``Statement.executeLargeUpdate(String sql, String[] columnNames)``

Значения в ``String[]`` - это имена столбцов, которые будут возвращены. Указанные имена столбцов обрабатываются как есть и не проверяются на валидность или необходимость кавычек. 
Предоставление несуществующих или неправильно (не)заключенных в кавычки столбцов приведет к исключению при обработке запроса в ``Firebird``. 
Этот метод является самым быстрым, поскольку он не получает метаданные с сервера.

.. warning::

    В ``Jaybird 3`` и более ранних версиях ``null`` или пустой массив молча игнорировался, и оператор выполнялся нормально (не создавая сгенерированных ключей). 
    В ``Jaybird 4`` будет выброшено исключение с сообщением ``«Generated keys array columnNames was empty or null. A non-empty array is required»``.

Пример использования имен столбцов
""""""""""""""""""""""""""""""""""""""

Получение ключей по имени в подготовленном операторе:

.. code-block::

    try (PreparedStatement statement = connection.prepareStatement(
            "insert into person(firstname, lastname, birthdate) values (?, ?, ?)",
            new String[] { "id", "\"age\"" })) { -- 1         
        statement.setString(1, "Mark");
        statement.setString(2, "Rotteveel");
        statement.setObject(3, LocalDate.of(1979, 1, 12));

        statement.executeUpdate();
        try (ResultSet keys = statement.getGeneratedKeys()) {
            if (keys.next()) {
            int generatedId = keys.getInt("id");
            int age = keys.getInt("age");

            System.out.printf("Id: %d, Age: %d%n",
                generatedId, age);
            }
        }
    }

Описание ключевых моментов, примеденных в примере:

1. Имена столбцов передаются как есть, для столбцов, чувствительных к регистру (и других имен, требующих кавычек), требуется правильное использование кавычек.

.. warning::

    Требование передавать имена столбцов в корректных кавычках не указано в стандарте ``JDBC``. 
    В следующих версиях ``Jaybird`` оно может измениться, чтобы имена столбцов передавались в том виде, в каком они возвращаются из ``DatabaseMetaData.getColumn``. 
    То есть, без кавычек, в точности как хранится в ``RDB$RELATION_FIELDS.RDB$FIELD_NAME``. Заключение в кавычки имен столбцов будет выполняться ``Jaybird``.
    Когда это изменится, будет предоставлено свойство соединения для обратной совместимости.


Настройка сгенерированных ключей
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Свойство соединения ``generatedKeysEnabled`` (псевдоним ``generated_keys_enabled``) позволяет настроить поведение сгенерированных ключей. 
Оно также доступно для источников данных.

Свойство принимает следующие значения (не чувствительно к регистру):

* ``default``: поведение по умолчанию для включения сгенерированных ключей для типов операторов с предложением ``RETURNING`` в подключенной версии ``Firebird``. Отсутствие этого свойства, ``null`` или пустая строка означают значение по умолчанию.
* ``disabled``: отключить поддержку сгенерированных ключей. Попытки использовать методы сгенерированных ключей, отличные от ``Statement.NO_GENERATED_KEYS``, вызовут исключение ``SQLFeatureNotSupportedException``.
* ``ignored``: игнорировать поддержку генерируемых ключей. Попытки использовать методы сгенерированных ключей не будут пытаться обнаружить поддержку сгенерированных ключей и будут выполняться так, как будто оператор не генерирует никаких ключей. ``Метод Statement.getGeneratedKeys()`` будет возвращать пустой результирующий набор. Такое поведение аналогично использованию методов, не генерирующих ключи.
* Список типов операторов, разделенный запятыми, который необходимо включить.

Для ``disabled`` и ``ignored``, ``DatabaseMetaData.supportsGetGeneratedKeys`` будет передавать ``false``.

Выборочное включение типов операторов
""""""""""""""""""""""""""""""""""""""""

Опция ``generatedKeysEnabled`` позволяет выборочно включать поддержку генерируемых ключей. 
Например, ``generatedKeysEnabled=insert`` включит ее только для вставки, игнорируя для всех остальных типов операторов. 
Типы операторов, для которых эта опция не включена, будут вести себя так, как будто они не генерируют никаких ключей. 
Для таких типов утверждений ``Statement.getGeneratedKeys()`` вернет пустой набор результатов.

Возможные значения типа утверждения (не чувствительны к регистру):

* ``insert``
* ``update``
* ``delete``
* ``update_or_insert``
* ``merge``

Другие значения будут проигнорированы.

Примеры: 

* ``jdbc:firebird://localhost/testdb?generatedKeysEnabled=insert`` - включит поддержку только для типа ``insert``.
* ``jdbc:firebird://localhost/testdb?generatedKeysEnabled=merge`` - включит поддержку только для типа ``merge``. Но только в ``Firebird 3.0`` и выше. 
* ``jdbc:firebird://localhost/testdb?generatedKeysEnabled=insert,update`` - включит поддержку только для операторов ``insert`` и ``update``.

Эта функция может быть использована для решения проблем с фреймворками или инструментами, которые всегда используют методы сгенерированных ключей для подготовки или выполнения. 
Например, операторы ``UPDATE``, которые затрагивают несколько записей, учитывая ограничения ``Firebird 4.0`` и более ранних версий для ``RETURNING``, 
выдают ошибку ``«multiple rows in singleton select»``.

Свойство соединения ignoreProcedureType
------------------------------------------------

В ``Firebird 2.1`` и выше ``Jaybird`` использует информацию о типе процедуры из метаданных базы данных, чтобы решить, как выполнить ``CallableStatement``. 
Если процедура является селективной, ``Jaybird`` автоматически преобразует оператор вызова или ``EXECUTE PROCEDURE`` в ``SELECT``.

В некоторых случаях автоматическое преобразование для использования ``SELECT`` приводит к проблемам. 
Можно явно задать ``FirebirdCallableStatement.setSelectableProcedure(false)``, чтобы устранить большинство из этих проблем, но это не всегда возможно. 
Например, ``@Procedure`` из ``spring-data-jpa`` не будет корректно работать с селективными процедурами, но при этом нельзя вызвать ``setSelectableProcedure``.

Чтобы отключить автоматическое использование информации о типе процедуры, необходимо установить свойство соединения ``ignoreProcedureType=true``. 
Можно использовать ``FirebirdCallableStatement.setSelectableProcedure(true)`` для выполнения процедуры с помощью ``SELECT``.

При использовании ``EXECUTE PROCEDURE`` с селективной процедурой, она выполняется только до первого ``SUSPEND``, а остальная часть хранимой процедуры не выполняется. 
Для ``Firebird 2.0`` и ниже это свойство не работает, так как там информация о типе процедуры недоступна.

Свойство подключения scrollableCursor
---------------------------------------

В ``Firebird 5.0`` и выше, ``Jaybird 5`` и выше поддерживаются прокручиваемые курсоры на стороне сервера. 

Эта функция доступна только в соединениях с использованием протокола ``PURE JAVA`` и только при явном включении свойства соединения ``scrollableCursor``.
Поддержка доступна только с использованием протокола ``PURE JAVA``, поскольку ``native`` и ``embedded`` соединения используют устаревший ``fbclient API``, 
а прокручиваемые курсоры не поддерживаются в устаревшем ``API fbclient``.

Свойство соединения ``scrollableCursor`` может принимать следующие значения (не чувствительны к регистру):

* ``EMULATED`` - использует кэшированный результат на стороне клиента; является значением по умолчанию.
* ``SERVER`` - использует прокручиваемые курсоры на стороне сервера, если это возможно.

Если соединение не поддерживает прокручиваемые курсоры или, если требуются удерживаемые курсоры, то прокручиваемые курсоры будут молча эмулироваться.

По сравнению с эмулированным прокручиваемым курсором, прокручиваемые курсоры на стороне сервера ведут себя иначе:

* Новые строки добавляются в конец курсора, в то время как при эмуляции они добавляются перед текущей строкой.
* Удаленные строки видны с полностью нулевой маркерной строкой, а при эмуляции удаленная строка удаляется из результирующего набора.
* Результирующие наборы теперь сообщают ``true`` для ``rowUpdated()``, ``rowDeleted()`` и ``rowInserted()`` для строк, обновленных, удаленных или вставленных в результат.

Свойство соединения useServerBatch
-----------------------------------------

Логическое свойство для настройки использования пакетных обновлений на стороне сервера. 
Значение по умолчанию - ``true``, чтобы использовать пакетные обновления на стороне сервера, когда это возможно. 
Установка значения в ``false`` отключает пакетные обновления на стороне сервера и включает эмулированные пакетные обновления.

Подробнее см. раздел :ref:`BATCHUPDATES`.

Свойство соединения serverBatchBufferSize
----------------------------------------------

Задает размер пакетного буфера на стороне сервера в байтах.

Возможные значения:

* ``< 0`` - использовать значение по умолчанию, установленное на стороне сервера (16 МБ, начиная с Firebird 4.0)
* ``0`` - использовать максимальное значение, установленное на стороне сервера (256 МБ, начиная с Firebird 4.0); является значением по умолчанию.
* ``> 0`` - размер пакетного буфера ограничивается максимальным размером на стороне сервера.

При слишком маленьком размере буфера будет использоваться 128 КБ или размер, необходимый для двух строк (в зависимости от того, что больше). 
При слишком больших размерах буфера будет использоваться максимальный размер на стороне сервера (256 МБ, начиная с ``Firebird 4.0``).

Подробнее см. раздел :ref:`BATCHUPDATES`.

Свойство соединения allowTxStmts
----------------------------------

Включает поддержку операторов управления транзакциями ``COMMIT [WORK]``, ``ROLLBACK [WORK]`` (без сохранения или точки сохранения) и ``SET TRANSACTION``.

Если эта функция отключена (``false``, по умолчанию), ``Jaybird`` будет отклонять попытки выполнить или подготовить эти операторы с одной из следующих ошибок:

* ``337248313 “Execution of COMMIT statement is not allowed, use Connection.commit(), or set connection property allowTxStmts to true”``
* ``337248314 “Execution of ROLLBACK statement is not allowed, use Connection.rollback(), or set connection property allowTxStmts to true”``
* ``337248315 “Execution of SET TRANSACTION statement is not allowed, use Connection.setTransactionIsolation(int) or FirebirdConnection.setTransactionParameters(..), or set connection property allowTxStmts to true”``

Если включено (``true``), ``Jaybird`` будет выполнять эти операторы при следующих условиях:

* Выполнение с помощью методов ``execute``, ``executeUpdate`` или ``executeLargeUpdate`` для ``Statement`` или ``PreparedStatement``.
* Для ``PreparedStatement`` оператор подготавливается с помощью одного из методов ``prepareStatement`` в ``Connection``.
* Если автокоммит отключен, выполнение ``COMMIT`` или ``ROLLBACK`` приведет к фиксации или откату текущей транзакции, или ничего не сделает, если текущей транзакции нет. Реализация не выполняет действующие операторы, а вместо этого вызывает ``Connection.commit()`` или ``Connection.rollback()``.
* Для оператора ``SET TRANSACTION``, если нет активной транзакции. Реализация выполняет оператор с использованием ``«execute immediate»``, что означает, что он не выполняется через дескриптор оператора.

Эти операторы будут выбрасывать ``SQLException`` при следующих условиях, когда оператор:

* Выполняется, когда включен режим автокоммита.
* Выполняется, когда соединение участвует в распределенной транзакции.
* Для оператора ``SET TRANSACTION`` - выполняется при наличии активной транзакции.
* Подготавливается с помощью методов ``prepareCall`` для ``Connection``.
* Выполняется с помощью методов ``executeQuery`` в ``Statement`` или ``PreparedStatement``.
* Добавляется в пакет (с помощью методов ``addBatch`` операторов ``Statement`` или ``PreparedStatement``).

Свойство ``allowTxStmts`` не действует на другие операторы управления транзакциями, т.е. 
``COMMIT [WORK] RETAIN``, ``ROLLBACK [WORK] RETAIN``, ``ROLLBACK [WORK] TO [SAVEPOINT] <name>``, ``SAVEPOINT <name>`` и ``RELEASE SAVEPOINT <name> [ONLY]``. 
Эти операторы могут быть выполнены всегда. Однако для методов, связанных с точкой сохранения, рекомендуется использовать соответствующие методы ``JDBC API``.

Свойство соединения extendedMetadata
-----------------------------------------

По умолчанию ``Jaybird`` запрашивает расширенную информацию о метаданных. Можно отключить этот запрос, установив для свойства соединения ``extendedMetadata`` значение ``false``.

Эта настройка действует только для следующих методов:

* ``ResultSetMetaData.getPrecision(int)`` - Если свойство ``extendedMetadata`` включено, запрашивается фактическая точность столбцов ``NUMERIC`` и ``DECIMAL``. Если отключено, точность будет оцениваться.
* ``ResultSetMetaData.isAutoIncrement(true)`` -  Если свойство ``extendedMetadata`` включено, состояние идентификационных столбцов ``INTEGER``, ``BIGINT`` и ``SMALLINT`` запрашивается в ``Firebird 3.0`` и выше. Если отключено, результат всегда будет ``false``.

При вызове любого из этих методов будут запрашиваться расширенные метаданные.

Если установить значение ``extendedMetadata`` в ``false``, производительность этих методов может повыситься, но снизится оценочная точность, также невозможно будет определить состояние автоинкремента столбца.





