Транзакции
================

Транзакции используются для объединения ``SQL-операторов`` в единый блок, который удовлетворяет свойствам ``ACID``:
атомарности, согласованности, изоляции и долговечности. Все операторы, выполняемые в одной транзакции,
либо будут успешно выполнены и их результат сохранится в базе данных, либо действие оператора будет отменено.

JDBC транзакции
------------------

``Firebird`` поддерживает несколько одновременных транзакций через одно и то же соединение с базой данных.
Это позволяет приложениям, работающим через нативный ``Firebird API``, уменьшить количество сетевых соединений, что сокращает потребление ресурсов на сервере.

В ``JDBC API`` каждое соединение с базой данных имеет одну и только одну активную транзакцию, связанную с ним.
Спецификация ``JDBC`` требует, чтобы драйвер запускал транзакцию автоматически, как только возникает необходимость в контексте транзакции.

Пример явного управления транзакциями:

.. code-block::

	Connection connection = ...

	connection.setAutoCommit(false);

	try (Statement stmt = connection.createStament()) {
		stmt.executeUpdate("UPDATE employee " +
			" SET salary = salary * 2");

		// ... do some more changes to database
		// to hide the identity of the person
		// that messed up the salary information
		// by deleting the audit trails logs, etc.

		stmt.executeUpdate("DELETE FROM audit_trails");

		connection.commit();
	} catch(SQLException ex) {
		connection.rollback();
	}

Для использования транзакции сначала отключается режим ``auto-commit``, затем создается объект ``java.sql.Statement`` и выполняется оператор ``UPDATE``.
Явного запуска транзакции не происходит, новая транзакция запускается непосредственно перед выполнением оператора.

При работе с базой данных, в которой сохранена целостность ссылок и в триггерах закодированы правила безопасности,
будет возникать ошибка, препятствующая очистке информации в журнале аудита.

.. note::

	В ``Firebird PSQL`` есть блок ``IN AUTONOMOUS TRANSACTION``, который можно использовать для предотвращения стирания записей аудита при откате транзакции.
	В качестве альтернативы можно использовать внешнюю таблицу для хранения журнала аудита.

Когда в соединении используется явное управление транзакциями, каждая транзакция должна быть завершена вызовом методов ``commit()`` или ``rollback()`` объекта ``Connection`` до того,
как соединение будет закрыто. Если транзакция не была завершена, но был вызван метод ``close``, активная транзакция откатывается автоматически.
Это также происходит, если транзакция не была завершена, соединение не было закрыто явно, и объект ``Connection`` стал пригодным для сбора мусора.

.. warning::

	Учитывая недетерминированную задержку сборки мусора, необходимо явно завершить транзакцию и закрыть соединение.
	В ``Jaybird 5`` был удален ряд завершающих элементов, поэтому откат транзакции через сборку мусора стал еще менее детерминированным.

Режим auto-commit
------------------------

Каждое новое соединение по умолчанию создаётся с режимом ``auto-commit``.
В этом режиме транзакция завершается, когда оператор завершен.
Момент, когда выполнение оператора считается завершенным, определяется в спецификации как:

* Для операторов вставки, обновления, удаления и ``DDL`` оператор считается завершенным, как только он закончит выполнение;
* Для операторов ``select`` оператор завершается, когда связанный с ним результат закрывается. Результирующий набор закрывается, как только происходит одно из следующих событий:

	* Все строки получены;
	* Связанный объект ``Statement`` выполнился повторно;
	* Другой объект ``Statement`` выполнился в же соединении.

* Для объектов ``CallableStatement`` оператор завершается, когда все связанные с ним результаты закрыты.

Если транзакция выполняется, а значение свойства ``auto-commit`` изменяется, то текущая транзакция будет зафиксирована.

Если соединение установлено с помощью ``javax.sql.DataSource`` и используются транзакции, управляемые контейнером
(например, приложение выполняется внутри контейнера ``EJB``), то вызов метода ``setAutoCommit`` приведет к ошибке.

Особую осторожность следует проявлять при использовании нескольких операторов в режиме автоматической фиксации.
Спецификация ``JDBC 2.0 не`` полностью определила правила завершения операторов, а также не определила поведение при наличии нескольких объектов ``ResultSet``,
созданных с использованием одного объекта соединения в режиме ``auto-commit``.

Поскольку ``Firebird`` не позволяет результирующему набору оставаться открытым после завершения транзакции,
``Jaybird 1.5.x`` и ниже кэшировал весь результат в памяти, когда выполнялись операторы ``SELECT`` и транзакция фиксировалась.
Это негативно сказывалось на объеме выделенной памяти, если результирующий набор был большим, особенно если он содержал ``BLOB``.
В спецификации ``JDBC 3.0`` эта ситуация была исправлена, и ``Jaybird 2.1`` был усовершенствован для корректной работы с большими результатами.
Это также позволило уменьшить занимаемую память - драйвер больше не кэширует прокручиваемые и не удерживаемые результаты.

``Java-приложения``, не соответствующие текущей спецификации ``JDBC``, могут перестать работать с ``Jaybird 2.1`` и выше.

Приведенный ниже пример работает с явным контролем транзакций.
Но он не будет корректно работать с автокоммитом в драйвере - например,
``Jaybird`` - который соответствует спецификации ``JDBC 3.0``, когда объекты ``selectStmt`` и ``updateStmt`` создаются одним и тем же объектом соединения.
Результирующий набор, созданный оператором ``SELECT``, должен быть закрыт перед выполнением ``UPDATE``.
Когда ``Java-приложение`` попытается получить следующую запись, вызвав метод ``rs.next()``, будет вызвано ``SQLException`` с сообщением ``«The result set is closed»``.

Правильным решением в данной ситуации является исправление явного управления транзакциями или использования двух объектов соединения,
одного для ``SELECT`` и одного для ``UPDATE``.

Несогласованное использование вложенных операторов в режиме ``auto-commit``:

.. code-block::

	try (Statement selectStmt = connection.createStatement();
		Statement updateStmt = connection.createStatement();
		ResultSet rs = selectStmt.executeQuery(
			"SELECT * FROM myTable")) {
		while(rs.next()) {
			int id = rs.getInt(1);
			String name = rs.getString(2);

			updateStmt.executeUpdate("UPDATE anotherTable SET " +
				" name = '" + name + "' WHERE id = " + id);
		}
	}

Чтобы решить эту проблему, в ``Jaybird 2.1`` появился параметр соединения ``defaultHoldable``, который оставляет результирующие наборы открытими по умолчанию.
Открытые результаты будут полностью кэшироваться в памяти, но не будут автоматически закрываться при завершении транзакции.
Это свойство также работает при отключении автокоммита.

Транзакции read-only
----------------------

Транзакция может быть объявлена ``read-only``, чтобы уменьшить вероятность конфликтов блокировок.
Это не имеет смысла для ``Firebird``, где чтение не блокирует запись и наоборот, но в некоторых случаях может быть полезно.

С транзакцией чтение-запись не разрешается подключаться  к базе данных, расположенной на носителе, доступном только для чтения, например, на ``CD-ROM``.
Для обеспечения согласованности транзакций чтения-записи ``Firebird`` должен увеличивать идентификатор транзакции при ее завершении и
сохранять новое значение на странице инвентаризации транзакций, даже если в этой транзакции не было сделано никаких изменений.
Это требование может быть смягчено, если транзакция объявлена только для чтения и сервер гарантирует, что никакие данные не могут быть изменены.

Длительные транзакции чтения-записи тормозят процесс обнаружения мусорных версий записей в базе данных.
Без сбора мусора размер базы данных будет расти быстро, а скорость выполнения операций снизится,
поскольку серверу придется проверять все доступные версии записей, чтобы определить подходящую.

Если транзакция не вносит изменения в базу данных, нужно использовать метод ``setReadOnly`` объекта ``java.sql.Connection``,
чтобы сообщить серверу, что транзакция предназначена только для чтения.

Уровни изоляции
--------------------

Стандарт ``ANSI/ISO SQL`` определяет четыре уровня изоляции, каждый следующий из которых слабее предыдущего.
Эти уровни изоляции используются в спецификации ``JDBC``:

.. tabularcolumns:: |>{\ttfamily\arraybackslash}\X{5}{15}|>{\arraybackslash}\X{10}{15}|
.. list-table:: Уровни изоляции в спецификации JDBC
   :class: longtable
   :header-rows: 1

   * - Уровень изоляции
     - Описание
   * - TRANSACTION_SERIALIZABLE
     - Уровнем изоляции, запрещающий фантомные чтения. Когда одна транзакция считывает все строки, удовлетворяющие условию ``WHERE``, другая транзакция вставляет строку, удовлетворяющую этому условию, и первая транзакция повторно выполняет оператор.
   * - TRANSACTION_REPEATABLE_READ
     - Уровень изоляции, предотвращающий повторные чтения. Когда строка считывается в одной транзакции, затем изменяется в другой транзакции и повторно считывается в первой. То есть рамках одной транзакции прочитаны разные значения.
   * - TRANSACTION_READ_COMMITTED
     - Уровень изоляции, при котором видны только зафиксированные записи. Но он не предотвращает повторные и фантомные чтения.
   * - TRANSACTION_READ_UNCOMMITTED
     - Уровень изоляции при котором видны еще не зафиксированные изменения от параллельно выполняющихся транзакций.

``Firebird`` определяет другие уровни изоляции: ``read_committed``, ``concurrency`` и ``consistency``.
Только уровень изоляции ``read_committed`` может быть сопоставлен со стандартом.
Грязные чтения исключены, повторные и фантомные чтения возможны.

Уровень изоляции ``concurrency`` строже, чем изоляция повторяющегося чтения, определенная в стандарте ``ANSI/SQL``,
удовлетворяет требованиям сериализуемого уровня изоляции и гарантирует более высокую производительность.

``Firebird`` предоставляет уровень изоляции ``READ CONSISTENCY``, который в сочетании с функцией резервирования таблиц обеспечивает безопасное выполнение транзакций.
Транзакция не будет запущена, если существует другая транзакция с пересекающимися наборами зарезервированных таблиц.
Этот уровень изоляции обеспечивает последовательную историю выполнения транзакций.

Чтобы соответствовать спецификации ``JDBC``, ``Jaybird`` предоставляет следующее соответствие между уровнями изоляции транзакций ``JDBC`` и уровнями изоляции ``Firebird``:

* ``TRANSACTION_READ_COMMITTED`` сопоставлен с уровнем изоляции ``read_committed`` в ``Firebird`` - любые изменения, сделанные внутри транзакции, не видны вне транзакции до тех пор, пока транзакция не будет зафиксирована. Транзакция в режиме ``read-committed`` видит все зафиксированные изменения, сделанные другими транзакциями, даже если они сделаны после начала текущей транзакции.
* ``TRANSACTION_REPEATABLE_READ`` сопоставлена с уровнем изоляции ``concurrency`` в ``Firebird`` - любые изменения, сделанные внутри этой транзакции, не видны вне транзакции до тех пор, пока транзакция не будет зафиксирована. Транзакция в режиме ``repeatable-read`` видит только те изменения, которые были зафиксированы до начала транзакции. Любое зафиксированное изменение в другой транзакции, произошедшее после начала этой транзакции, не видно в этой транзакции.
* ``TRANSACTION_SERIALIZABLE`` соответствует уровню изоляции ``consistency`` в ``Firebird`` - любое изменение таблицы происходит последовательно: все транзакции ждут, пока завершится изменение в текущей.

Сопоставление по умолчанию задается в коде ``Jaybird`` и может быть переопределено в свойствах соединения.

* Через свойство ``tpbMapping``, указывающее имя ``ResourceBundle`` с новым соответствием уровня изоляции;
* Через прямое указание уровня изоляции транзакций ``JDBC``. Ниже пример такой операции, значения в маппинге описаны в разделе `Буфер параметров транзакции`_.
* Через конфигурацию источника данных.

Переопределение сопоставления уровней изоляции:

.. code-block::

	Properties props = new Properties();
	props.setProperty("user", "SYSDBA");
	props.setProperty("password", "masterkey");
	props.setProperty("TRANSACTION_READ_COMMITTED",
		"read_committed,no_rec_version,write,nowait");

	Connection connection = DriverManager.getConnection(
		"jdbc:firebirdsql://localhost:3050/c:/example.fdb",
		props);

.. note::

	Свойства принимают сокращённые имена, как показано в примере, или обычные имена с префиксом isc_dpb\_,
	как определено в ``org.firebirdsql.jaybird.fb.constants.TpbItems`` (``Jaybird 5``) или ``org.firebirdsql.gds.ISCConstants`` (старые версии).
	Для удобства рекомендуется использовать сокращённые имена.

Переопределенное отображение будет использоваться для всех транзакций, запущенных в рамках одного соединения с базой данных.
Если отображение переопределено в конфигурации источника данных, оно будет использоваться для всех соединений, созданных этим источником.

Точки сохранения
---------------------

Точки сохранения обеспечивают более тонкий контроль над транзакциями, обеспечивая промежуточные шаги в рамках более крупной транзакции.
После установки точки сохранения транзакция может быть к ней откачена.

Пример использования точек сохранения:

.. code-block::

	Connection connection = ...;
	connection.setAutoCommit(false);

	try (Statement stmt = connection.createStatement()) {
		stmt.executeUpdate(
			"INSERT INTO myTable(id, name) VALUES (1, 'John')");

		Savepoint savePoint1 =
			connection.setSavepoint("savepoint_1");

		stmt.executeUpdate(
			"UPDATE myTable SET name = 'Ann' WHERE id = 1");
		// ...

		connection.rollback(savePoint1);

		// at this point changes done by second update are undone
	}

Откат к точке сохранения автоматически освобождает и делает недействительными все точки сохранения, которые были созданы после этого.

Если точка сохранения больше не нужна, можно использовать метод ``Connection.releaseSavepoint`` для освобождения системных ресурсов.
После выхода из точки сохранения уже невозможно откатить к ней текущую транзакцию. Вызов метода ``rollback(Savepoint)`` приведёт к возникновению исключения.
Точки сохранения, созданные в транзакции, автоматически освобождаются при фиксации или откате транзакции.

Буфер параметров транзакции
------------------------------

Поведение транзакций ``Firebird`` контролируется буфером параметров транзакций (``Transaction Parameter Buffer``, ``TPB``), который определяет свойства транзакций:

* Уровень изоляции транзакции;
* Режим транзакции - ``read-only`` или ``read-write``;
* Режим разрешения конфликта блокировок - ``wait`` или ``no wait``;
* Таймаут ожидания блокировки;
* Резервирование таблиц - имена и режимы резервирования.

``TPB`` создаётся автоматически в зависимости от уровня изоляции транзакций, указанного для объекта ``java.sql.Connection``.
Если соединение установлено в режиме ``read-only``, это отражается в ``TPB`` соответствующей константой.

Режим разрешения блокировок, а также резервирование таблиц не могут быть заданы с помощью стандартных интерфейсов ``JDBC``.
Для случаев, когда это необходимо, ``Jaybird`` предоставляет расширение стандарта ``JDBC``.

Пример определения пользовательского ``TPB``:

.. code-block::

	FirebirdConnection fbConnection =
    	connection.unwrap(FirebirdConnection.class);

	TransactionParameterBuffer tpb =
		fbConnection.createTransactionParameterBuffer();

	tpb.addArgument(TpbItems.isc_tpb_read_committed);
	tpb.addArgument(TpbItems.isc_tpb_rec_version);
	tpb.addArgument(TpbItems.isc_tpb_write);
	tpb.addArgument(TpbItems.isc_tpb_wait);
	tpb.addArgument(TpbItems.isc_tpb_lock_timeout, 15);

	fbConnection.setTransactionParameters(tpb);

Константы, используемые в примерах этой главы, были введены в ``Jaybird 5``. В более ранних версиях одноименные константы определены в ``org.firebirdsql.gds.ISCConstants``,
а константы с аналогичным названием - в ``org.firebirdsql.gds.TransactionParameterBuffer`` (т. е. без префикса ``isc_tpb_`` и с полной заглавной буквы).
Эти старые константы будут удалены в ``Jaybird 6`` в пользу ``org.firebirdsql.jaybird.fb.constants.TpbItems``.

Уровень изоляции
~~~~~~~~~~~~~~~~~~~

``Firebird`` поддерживает три уровня изоляции: ``read_committed``, ``concurrency`` и ``consistency``, которые представлены соответствующими константами в классе ``TpbItems``.
Уровень изоляции определяет способ, которым сервер базы данных обрабатывает версии записей при операциях чтения.
Уровень изоляции ``concurrency`` также часто называют ``SNAPSHOT``, а уровень изоляции ``consistency`` - ``SNAPSHOT TABLE STABILITY``.

В режимах ``consistency`` и ``concurrency`` сервер базы данных ``Firebird`` загружает с диска различные версии одной и той же записи,
проверяет "временные метки" каждой версии и сравнивает их с "временной меткой" текущей транзакции.
Версия записи с наибольшей временной меткой, которая при этом меньше или равна временной метке текущей транзакции, возвращается приложению.
Это позволяет вернуть версию записи, которая была зафиксирована до старта текущей транзакции и обеспечивает
отсутствие повторного и фантомного чтения.

В режиме ``read_committed`` сервер базы данных ``Firebird`` получает доступ к версии записи с наибольшей временной меткой,
для которой соответствующая транзакция отмечена как зафиксированная. Это предотвращает чтение версий записей, которые были изменены в параллельных транзакциях,
которые еще не зафиксированы или были откачены по какой-либо причине.
Но такой режим допускает повторные и фантомные чтения, если параллельная транзакция, изменявшая записи или вставлявшая новые, была зафиксирована.

Для режима изоляции ``read_committed`` требуется еще одна константа, определяющая поведение транзакции, когда она видит версию записи с временной меткой,
принадлежащей текущей транзакции, которая еще не зафиксирована.

Для большинства приложений требуется режим ``TpbItems.isc_tpb_rec_version``, или ``READ COMMITTED RECORD VERSION``, который показан в примере выше.
В этом режиме сервер базы данных получает последнюю зафиксированную версию.

Константа ``TpbItems.isc_tpb_no_rec_version`` или ``READ COMMITTED NO RECORD VERSION`` указывает серверу базы данных сообщать о конфликте блокировок,
если при получении данных из базы данных обнаружена нефиксированная версия записи. Результат операции контролируется режимом разрешения блокировки.

``TpbItems.isc_tpb_read_consistency`` использует режим ``READ COMMITTED READ CONSISTENCY``, введенный в ``Firebird 4.0``.

.. warning::

	``Firebird 4.0`` и выше по умолчанию использует ``isc_tpb_read_consistency`` и игнорирует ``isc_tpb_rec_version`` и ``isc_tpb_no_rec_version``.
	Это контролируется с параметром ``ReadConsistency`` в ``firebird.conf`` или ``databases.conf``.

Транзакции read-only
~~~~~~~~~~~~~~~~~~~~~~~

Режимы транзакций ``read-only`` и ``read-write`` управляются двумя константами:

* ``TpbItems.isc_tpb_read``
* ``TpbItems.isc_tpb_write``

Когда указан режим ``read-write`` (константа ``isc_tpb_write``), сервер базы данных сохраняет «временную метку» новой транзакции в базе данных,
даже если в транзакции не будет произведено никаких изменений. «Временная метка» влияет на процесс сборки мусора,
поскольку не могут освободиться записи, которые были изменены в транзакциях с более высокими «временными метками»,
даже если уже существуют новые версии записей. Таким образом, длительная транзакция чтения-записи тормозит сборку мусора, даже если в ней не происходит никаких изменений.

Поэтому рекомендуется использовать режим ``read-only`` для транзакции, которая выполняет только чтение.

Режим разрешения блокировки
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Реляционные системы баз данных блокируют записи независимо от типа операции, чтения или записи.
Когда приложение пытается прочитать запись из базы данных, сервер базы данных пытается установить блокировку на чтение этой записи.
Если операция выполняется успешно, а затем приложение пытается обновить запись, то заблокируется возможность записи.
Если ресурс уже заблокирован на запись, параллельные транзакции не могут заблокировать его на чтение,
поскольку система не может позволить транзакции принять решение на основе данных, которые впоследствии могут быть откачены.
Такой подход значительно снижает вероятность возникновения параллелизма.
В системах баз данных, использующих механизм версионирования записей, таких ограничений нет,
поскольку каждая транзакция видит свою версию записи.
Единственный случай, когда может возникнуть конфликт - две параллельные транзакции пытаются установить блокировку на запись для одной и той же записи в базе данных.

В ``Firebird`` нет конфликтов блокировок между читающими и пишущими, и только пишущие, конкурирующие за один и тот же ресурс, вызывают конфликт блокировок.
Но с уровнем изоляции ``consistency`` операции чтения будут конфликтовать с операциями записи. Более того, блокировки устанавливаются на целые таблицы.

Следующая таблица обобщает вышесказанное для ``Firebird 2.0``. Из нее видно, что транзакции ``read-commited`` или ``repeatable`` read конфликтуют только тогда,
когда они одновременно обновляют одни и те же строки. В отличие от этого, транзакция ``consistency`` конфликтует с любой транзакцией, работающей в режиме ``read-write``,
как только транзакция ``consistency`` получает доступ на запись к таблице, другим транзакциям ``read-write`` запрещается вносить изменения в эту таблицу.

.. tabularcolumns:: |>{\centering\arraybackslash}\X{4}{14}|>{\ttfamily\arraybackslash}\X{3}{14}|>{\ttfamily\arraybackslash}\X{3}{14}|>{\ttfamily\arraybackslash}\X{2}{14}|>{\ttfamily\arraybackslash}\X{2}{14}|
.. list-table::
   :class: longtable
   :header-rows: 1

   * -
     - Read-committed, Concurrency read-write
     - Read-committed, Concurrency read-only
     - Consistency, read-write
     - Consistency, read-only
   * - **Read-committed, Concurrency read-write**
     - Некоторые обновления могут вызвать конфликт
     -
     - Конфликт
     - Конфликт
   * - **Read-committed, Concurrency read-only**
     -
     -
     -
     -
   * - **Consistency read-write**
     - Конфликт
     -
     - Конфликт
     - Конфликт
   * - **Consistency read-only**
     - Конфликт
     -
     - Конфликт
     -

Резервирование таблиц
---------------------------

Резервирование таблиц позволяет указать режим доступа для таблицы в начале транзакции.
При запуске транзакции сервер пытается установить запрошенные блокировки для указанных таблиц и продолжает работу только после того, как все блокировки успешно установлены.
Такое поведение позволяет создать историю выполнения взаимных блокировок (``deadlock``).

Резервирование таблиц задается с помощью ``TPB`` и включает таблицу для блокировки, режим блокировки и тип блокировки.

Пример использования резервирования таблиц:

.. code-block::

	FirebirdConnection connection = ...
	TransactionParameterBuffer tpb =
		connection.createTransactionParameterBuffer();

	tpb.addArgument(TpbItems.isc_tpb_consistency);
	tpb.addArgument(TpbItems.isc_tpb_write);
	tpb.addArgument(TpbItems.isc_tpb_nowait);

	tpb.addArgument(TpbItems.isc_tpb_lock_write,
		"TEST_LOCK");
	tpb.addArgument(TpbItems.isc_tpb_protected);

	connection.setTransactionParameters(tpb);

	// next transaction will lock TEST_LOCK table for writing
	// in protected mode

В примере показано резервирование таблицы ``TEST_LOCK`` для записи в режиме ``protected``. При этом выполняются следующие действия:

* Создание нового экземпляра класса ``TransactionParameterBuffer``.
* Заполнение ``TPB``. Первые три оператора были описаны в разделе `Буфер параметров транзакции`_. Четвертый вызов указывает, что нужно установить блокировку на таблицу ``TEST_LOCK`` для записи. Пятый вызов указывает тип блокировки, в примере - ``protected lock``.
* Установка нового ``TPB``, который будет использован для следующей транзакции.

Режим блокировки таблицы, указанный в ``TPB``:

* ``TpbItems.isc_tpb_lock_read`` для доступа к таблице только для чтения;
* ``TpbItems.isc_tpb_lock_write`` для доступа к таблице для чтения и записи.

Тип блокировки:

* ``TpbItems.isc_tpb_shared`` для общего доступа к таблице;
* ``TpbItems.isc_tpb_protected`` для защищенного доступа к таблице;
* ``TpbItems.isc_tpb_exclusive`` - был введен в более поздних версиях ``Firebird``, ведет себя как режим ``TpbItems.isc_tpb_protected`` для всех транзакций чтения-записи.

Конфликты блокировок в зависимости от уровня изоляции:

* ``isc_tpb_lock_write`` всегда конфликтует с другим режимом ``isc_tpb_lock_write`` независимо от типа блокировки и уровня изоляции транзакций;
* ``isc_tpb_lock_write`` всегда конфликтует с другим режимом ``isc_tpb_lock_read``, если обе транзакции выполняются с уровнем изоляции ``consistency``, но не конфликтует с блокировками ``shared-read``, если другая транзакция имеет уровень изоляции concurrency или ``read_committed``;
* ``isc_tpb_lock_read`` никогда не конфликтует с режимом ``isc_tpb_lock_read``.

Операторы управления транзакциями
------------------------------------

В ``Firebird`` есть ряд операторов управления транзакциями.
В этом разделе будут рассмотрены операторы ``COMMIT [WORK]``, ``ROLLBACK [WORK]`` и ``SET TRANSACTION``,
которые имеют жесткие границы транзакции (либо завершение, либо начало транзакции).

Спецификация ``JDBC`` формально не рекомендует использовать операторы или функциональность, которая доступна через ``JDBC API``:
"При настройке соединения приложения ``JDBC`` должны использовать соответствующий метод соединения, такой как ``setAutoCommit`` или ``setTransactionIsolation``.
Приложения не должны напрямую вызывать ``SQL-операторы`` для изменения конфигурации соединения, если доступен метод ``JDBC``."

В ``Jaybird 5`` и старше операторы ``COMMIT`` и ``ROLLBACK`` иногда могут быть выполнены, но они приводят соединение в несогласованное состояние,
что препятствует дальнейшему использованию соединения, а выполнение оператора ``SET TRANSACTION`` всегда будет ошибочным, поскольку он выполняется с активной транзакцией.

Начиная с ``Jaybird 6``, эти операторы отклоняются по умолчанию, но их поддержку можно включить с помощью парамерта соединения ``allowTxStmts``.

Разрешение выполнения этих операторов иногда может быть полезным, например, для выполнения скриптов или упрощения доступа к более продвинутым функциям конфигурации транзакций,
таким как резервирование таблиц.
