Обработка исключений
==========================

Обработка исключений - важный аспект, напрямую влияющий на стабильность работы приложения.
Правильная обработка ошибок гарантирует корректную работу как клиентской части, так и сервера базы данных.

Все методы интерфейсов, определенные в спецификации ``JDBC``, выбрасывают экземпляры ``java.sql.SQLException`` для уведомления об ошибках,
возникающих при обработке запроса. ``SQLException`` является проверяемым исключением, что вынуждает ``Java-программистов`` либо обрабатывать
его с помощью ``try/catch``, либо заново объявлять его в методе.

Работа с исключениями
------------------------

Продумать обработку исключений в приложении нужно до написания кода.
Сложно изменить шаблон обработки исключений в существующем коде.
Изменения затронут все слои, расположенные выше места, где вносятся изменения в обработку исключений.

Экземпляры ``java.sql.SQLException`` - это единственный способ для реляционной СУБД или драйвера ``JDBC`` сообщить об ошибке, возникшей во время обработки запроса.
Проверив код ошибки, который передается вместе с исключением, приложение может попытаться исправить ошибку.

Когда в методе возникает исключение, а поток выполнения Java-кода отличается от обычного, только правильно спроектированное приложение гарантирует, что все выделенные ресурсы будут освобождены.
В данном случае ресурсами являются ``JDBC-соединения``, операторы, наборы результатов и т. д.
Все эти объекты не только занимают память в виртуальной машине ``Java`` приложения, но и потребляют память на сервере,
что в худшем случае может привести к непреднамеренной атаке ``Denial-of-Service``, так как сервер базы данных больше не сможет обслуживать запросы.

Хорошая стратегия обработки исключений требует различать три состояня ошибки:

* ошибки, которые можно обнаружить на уровне доступа к базе данных и правильно обработать;
* ошибки, которые могут быть выявлены на уровне доступа к базе данных, но не могут быть обработаны;
* ошибки, которые не могут быть обнаружены на уровне доступа к базе данных без дополнительного кода, не связанного с функциональностью этого уровня.

Стратегия обработки заключается в следующем:

* обработка выбранных кодов ошибок для случаев, описанных выше;
* преобразование стандартного ``SQLException`` в стандартную ошибку в приложении
  (это может быть выброс какого-либо стандартного исключения, определенного в приложении,
  но также может быть запись в журнале событий приложения и короткое сообщение с просьбой повторить операцию позже);
* тактика экстренного реагирования, поскольку произошедшая ошибка (например, ``NullPointerException`` или ``OutOfMemoryError``) не была учтена при создании приложения и,
  возможно, привела его в неизвестное состояние; дальнейшая работа является опасной, и соответствующая ветвь выполнения должна быть остановлена.

Проблема управления ресурсами может быть решена, если выделение и освобождение ресурсов происходит в одном блоке кода и защищено блоком ``try-with-resources``.
Код для восстановления после ошибок должен использовать блоки ``try/catch``.
Пример такого кода обработки ошибок и ресурсов представлен ниже:

.. code-block::

	String updateString = "update COFFEES " +
    	"set SALES = ? where COF_NAME like ?";

	try (PreparedStatement updateSales = con.prepareStatement(updateString)) {
		int [] salesForWeek = {175, 150, 60, 155, 90};
		String [] coffees = {"Colombian", "French_Roast",
			"Espresso", "Colombian_Decaf",
			"French_Roast_Decaf"};

		int len = coffees.length;

		for(int i = 0; i < len; i++) {
			updateSales.setInt(1, salesForWeek[i]);
			updateSales.setString(2, coffees[i]);

			try {
				updateSales.executeUpdate();
			} catch(SQLException ex) {
			  if (ex.getErrorCode() == ...) {
				// do something
			  } else {
				throw new BusinessDBException(ex);
			  }
			}
		}
	}

Вложенный блок ``try/catch`` показывает пример обработки ошибки  взаимной блокировки (``deadlock``), если она произошла (первый сценарий по классификации, приведённой выше),
в противном случае исключение будет преобразовано и передано на верхние уровни (второй сценарий).

Возможная ошибка в драйвере ``JDBC`` могла сгенерировать исключение во время выполнения в методе ``PreparedStatement.executeUpdate()``,
что привело бы к нарушению обработки оператора, если бы для очистки ресурсов не был использован блок ``try-with-resource``.
Объявляйте и выделяйте ресурсы в блоке ``try-with-resources``: ресурс будет автоматически закрыт/освобожден в конце блока, даже если возникнут исключения.

Такая практика написания кода может показаться странной, поскольку, на первый взгляд, вся цель использования ``PreparedStatement`` игнорируется:
оператор подготавливается, используется только один раз и затем удаляется.
днако, в сочетании с пулом соединений и операторов эта практика приносит огромные преимущества коду приложения.
Код становится гораздо более управляемым - выделение и освобождение ресурсов происходит в одном и том же методе,
и разработчику программного обеспечения не нужно запоминать места, где может использоваться один и тот же подготовленный оператор.
Пул операторов либо повторно использует оператор, либо подготовит новый, если обнаружит, что все подготовленные операторы в пуле в настоящее время используются.
Как побочный эффект, приложение всегда будет использовать минимальное количество обработчиков операторов, что, в свою очередь, снижает потребление ресурсов на стороне базы данных.

.. warning::

	В настоящее время ``Jaybird`` не поставляет пул подготовленных операторов самостоятельно, доступность зависит от используемой библиотеки пула соединений.

Предупреждения
-------------------

Некоторые ошибки, возвращаемые ``Firebird``, рассматриваются как предупреждения. Они преобразуются в экземпляры класса ``java.sql.SQLWarning`` на уровне ``JDBC``.
Эти исключения не выбрасываются методами драйвера, а добавляются в экземпляр соединения.

.. note::

	В настоящее время предупреждения не добавляются для объектов ``Statement`` или ``ResultSet``.

Пример работы с предупреждениями:

.. code-block::

	import java.sql.*;
	....
	SQLWarning warning = connection.getWarnings();
	while (warning != null) {
		.... // do something with the warning
		warning = warning.getNextWarning();
	}

Другой вариант работы с предупреждениями:

.. code-block::

	import java.sql.*;
	....
	for (Throwable throwable : connection.getWarnings()) {
		if (throwable instanceof SQLWarning) {
			SQLWarning warning = (SQLWarning) throwable;
			.... // do something with the warning
		}
	}

Во втором примере выполняется итерация по первому предупреждению, всем его причинам (если они есть), затем по другим предупреждениям (если они есть) и так далее.

Чтобы удалить существующие предупреждение, вызовите метод ``Connection.clearWarnings()``.
