Выполнение операторов
============================

После установки соединения можно выполнять ``SQL-операторы``. Спецификация ``JDBC`` различает три вида операторов:

* Операторы для выполнения ``SQL-операторов`` без параметров;
* Подготовленные операторы для выполнения ``SQL-операторов`` с параметрами;
* Вызываемые операторы для выполнения хранимых процедур.

Интерфейс java.sql.Statement
----------------------------------

Интерфейс ``java.sql.Statement`` - это интерфейс для выполнения ``SQL-операторов``. Он различает три типа операторов:

* Операторы, которые возвращают результирующий набор, то есть запросы;
* Операторы, которые изменяют состояние базы данных, но не возвращают результат;
* Операторы вставки (``INSERT`` или другие операторы с похожим поведением), которые возвращают значения столбцов, сгенерированные сервером базы данных при вставке записи.

В целом схема использования оператора состоит из трех шагов. Ниже представлен типичный способ выполнения запроса для получения информации о пользователе:

.. code-block::

	try (Statement stmt = connection.createStatement(); -- 1
		ResultSet rs = stmt.executeQuery(
			"SELECT firstName, lastName FROM users" +
			" WHERE userId = 5") -- 2
	){
		if (rs.next()) {
			String firstName = rs.getString(1);
			String lastName = rs.getString(2);
		}
	} -- 3

#. Создание объекта ``Statement``, вызовом метода ``createStatement()`` объекта ``Connection``.
#. Использование объекта ``Statement``, вызовом его методов. В примере выполняется простой запрос ``SELECT firstName, lastName FROM users WHERE userId = 5``.
#. Освобождение выделенных ресурсов. В примере это реализовано с помощью блока ``try-with-resources``.
   С помощью ``try-with-resources`` ``Java`` выполняет закрытие ресурсов в правильном порядке,
   даже если возникают исключения или если ресурс не был выделен (например, если ``executeQuery`` выбрасывает исключение).

Поскольку объект соединения является фабрикой для объектов операторов, это накладывает ограничение на время жизни объекта: операторы привязаны к соединению;
когда соединение закрывается, все операторы, созданные с помощью этого соединения, становятся недействительными, а выделенные им ресурсы освобождаются.
Однако, несмотря на то, что ресурсы освобождаются при закрытии соединения, рекомендуется использовать блок ``try-with-resources``,
чтобы обеспечить освобождение ресурсов как можно быстрее.

Оператор может быть выполнен с помощью следующих методов:

* ``Statement.executeQuery(String)`` - выполняет оператор ``SELECT`` и возвращает результирующий набор.
  Если указанный оператор не возвращает результирующий набор, то после выполнения оператора будет выброшено ``SQLException``.
* ``Statement.executeUpdate(String)`` - выполняет другие операторы ``DML`` (например, ``INSERT``, ``UPDATE``, ``DELETE``) или ``DDL``
  и возвращает количество обновленных строк. Если указанный оператор является запросом или иным образом выдает набор результатов, будет выброшено ``SQLException``.
* ``Statement.execute(String)`` - выполняет оператор и возвращает ``true``, если оператор вернул результирующий набор,
  в противном случае было выполняет обновление и возвращает ``false``. Можно использовать метод ``Statement.getResultSet()``,
  чтобы получить результат выполненного запроса, или ``Statement.getUpdateCount()``, если был выполнен оператор обновления.

Оператор закрывается вызовом метода ``Statement.close()`` или с помощью ``try-with-resources``, которые вызывают ``close()`` **за кулисами (это конечно цирк но вряд ли тут кулисы)**.
После закрытия объект оператора становится недействительным и больше не может быть использован.

Допускается использование одного и того же объекта для выполнения различных типов запросов друг за другом.
Приведенный ниже пример сначала выполняет ``select`` для поиска ``ID`` пользователя ``Joe Doe``, и если запись найдена, то активирует его учетную запись.

.. warning::

	Объединение значений в запрос, как это сделано в примере ниже, может сделать код уязвимым для ``SQL-инъекций``.
	В данном конкретном случае это безопасно, поскольку значения являются целыми числами, но вместо этого лучше использовать подготовленный запрос с параметрами.

Пример использования одного и того же объекта оператора несколько раз для активации учетной записи пользователя:

.. code-block::

	try (Statement stmt = connection.createStatement();
		ResultSet rs = stmt.executeQuery(
			"SELECT userId FROM users " +
			"WHERE lastName = 'Doe' AND firstName = 'Joe'")) {
	if (rs.next()) {
		int userId = rs.getInt(1);

		int rowsUpdated = stmt.executeUpdate(
			"UPDATE accounts SET accountEnabled = 1 " +
			"WHERE userId = " + userId);

		if (rowsUpdated == 0)
			rowsUpdated = stmt.executeUpdate(
				"INSERT INTO accounts (userId, enabled) " +
				"VALUES (" + userId + ", 1)");

			if (rowsUpdated != 1)
			throw new SomeException(
				"User was not updated correctly.");
		}
	}

Построение кода довольно сложно из-за ограничений на время жизни результирующего набора, которые определены спецификацией ``JDBC``.
Однако здесь это сделано намеренно, чтобы подчеркнуть, что для выполнения операторов ``SELECT`` и ``UPDATE/INSERT`` используется один объект.
В примере также показано, как проверить, изменил ли выполненный оператор ожидаемое количество строк - приложение сначала пытается обновить учетную запись,
и только если ни одна строка не была обновлена, вставляет новую запись в таблицу ``accounts``.

Подход ``"попробуй обновить, а потом вставить"`` можно улучшить с помощью ``MERGE`` или ``UPDATE OR INSERT``.

Для выполнения ``DDL-запросов``, рекомендуется использовать метод ``Statement.execute(String)``,
так как в этом случае количество измененных записей не имеет смысла.
В следующем примере показано создание таблиц базы данных с помощью этого метода:

.. code-block::

	try (Statement stmt = connection.createStatement()) {
	stmt.execute("CREATE TABLE customer(" +
		"customerId INTEGER NOT NULL PRIMARY KEY, " +
		"firstName VARCHAR(20) NOT NULL, " +
		"lastName VARCHAR(40) NOT NULL)");
	}

Метод ``Statement.execute(String)`` также можно использовать для выполнения операторов типа ``unknown``:

.. code-block::

	try (Statement stmt = connection.createStatement()) {
		boolean hasResultSet = stmt.execute(sql);
		if (hasResultSet) {
			ResultSet rs = stmt.getResultSet();
			...
		} else {
			int updateCount = stmt.getUpdateCount();
			...
		}
	}

Согласно спецификации JDBC методы ``getResultSet()`` и ``getUpdateCount()`` могут быть вызваны только один раз для каждого результата,
а в случае использования ``Firebird`` это означает один раз для каждого выполненного оператора,
поскольку ``Firebird`` не поддерживает несколько результатов для одного оператора.
Вызов методов во второй раз приведет к возникновению исключения.

Фоновые действия при выполнении оператора
-------------------------------------------

Предыдущие примеры требуют подробного описания динамики объекта ``statement``, его жизненного цикла и того, как он влияет на другие подсистемы.

Порядов выполнения оператора
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Когда ``Java-приложение`` выполняет оператор, на фоне происходит множество других операций:

#. На сервере выделяется новый объект ``statement``. ``Firebird`` возвращает 32-битный идентификатор выделенного объекта,
   дескриптор оператора, который должен использоваться в следующих операциях.
#. ``SQL-оператор`` компилируется в исполняемую форму и связывается с указанным дескриптором оператора.
#. ``Jaybird`` запрашивает у сервера описание оператора, и ``Firebird`` возвращает информацию о типе оператора и допустимых входных и выходных параметрах.
#. Если для оператора не требуется никаких параметров, ``Jaybird`` сообщает ``Firebird`` о необходимости выполнить оператор, передавая его дескриптор в соответствующий метод.

После этого ``Jaybird`` принимает решение в зависимости от того, какая операция была вызвана:

#. Если использовалась операция ``Statement.execute()``, ``Jaybird`` проверяет только тип оператора, чтобы решить, должен ли он возвращать ``true``,
   сообщая приложению, что для этой операции есть результирующий набор, или ``false``, если оператор не возвращает результат.
#. Если был вызван метод ``Statement.executeUpdate()``, ``Jaybird`` запрашивает у ``Firebird`` информацию о количестве обработанных строк.
   Этот метод может быть вызван только в том случае, если тип оператора говорит о том, что результирующего набора не будет.

   Когда он вызывается для запросов, возникает исключение, несмотря на то, что утверждение было успешно выполнено на сервере.
#. Если был вызван ``Statement.executeQuery()`` и тип оператора указывает на то, что набор результатов может быть возвращен,
   ``Jaybird`` создает объект ``ResultSet`` и возвращает его приложению. Никаких дополнительных проверок, например, содержит ли набор результатов строки,
   не выполняется, поскольку за это отвечает объект ``ResultSet``.

.. warning::

	Описанное поведение может измениться в будущем, если перед выполнением оператора будет вызвано исключение.

Если не нужно знать, сколько строк было изменено, лучше использовать метод ``execute()`` вместо ``executeUpdate()``.
Это избавляет от дополнительного обращения к серверу для получения количества измененных строк, что может повысить производительность в ситуациях,
когда сетевая задержка сопоставима с временем выполнения оператора.

Метод ``execute()`` также является единственным методом, который можно использовать, если не известно, какой тип оператора выполняется
(например, приложение, позволяющее пользователю вводить ``SQL-запросы`` для выполнения).

После использования объекта приложение должно закрыть его. Существует два способа сделать это: закрыть объект ``ResultSet``,
связанный с дескриптором оператора, и закрыть оператор полностью.

Если нужно выполнить другой запрос, нет необходимости полностью освобождать выделенный оператор.
``Jaybird`` потребует только скомпилировать новый оператор перед его использованием, то есть можно пропустить шаг 1.
Это сэкономит одно обращение к серверу по сети, что повысит производительность приложения.

Если полностью закрыть оператор, выделенный дескриптор больше нельзя будет использовать.
``Jaybird`` мог бы выделить новый дескриптор оператора, однако спецификация ``JDBC`` не позволяет использовать объект ``Statement`` после вызова метода ``close()``.

Жизненный цикл оператора и DDL
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Когда сервер ``Firebird`` получает команду ``prepare statement``, он разбирает ``SQL-оператор`` и преобразует его в исполняемую форму: ``BLR``.
``BLR``, или представление двоичного языка, содержит низкоуровневые команды для обхода таблиц базы данных, условия, которые используются для фильтрации записей,
определяют порядок доступа к записям, индексы, которые используются для повышения производительности, и т. д.

Подготовленный оператор содержит ссылки на все определения объектов базы данных, которые используются во время выполнения этого оператора.

Однако сохранение ссылок на объекты базы данных имеет один неприятный эффект: невозможно обновить схему базы данных,
если есть активные соединения с базой данных с открытыми операторами, ссылающимися на обновляемые объекты.
Если запущены два приложения и одно из них пытается изменить определение таблицы, представления, процедуры или триггера,
а другое обращается к этим объектам, то первое получит ошибку ``335544453 «object is in use»``.

Для избежания этой проблемы, рекомендуется закрывать оператор, как только в нем отпадет необходимость.
Это удалит ``BLR`` и освободит все ссылки на объекты базы данных, сделав их доступными для изменения.

При использовании пула операторы не будут освобождены, даже если вызвать метод ``close()``.
Единственный способ закрыть пул операторов - это закрыть пул соединений.

Интерфейс java.sql.PreparedStatement
-----------------------------------------

Объект ``PreparedStatement`` представляет собой предварительно скомпилированный оператор, который может быть выполнен несколько раз.
Если используется поток выполнения, описанный в разделе `Порядов выполнения оператора`_, это позволит перейти к шагу 4 для повторного выполнения.

``JDBC`` обеспечивает поддержку параметризованных операторов - операторов, в которых литералы заменены вопросительными знаками (``?``), так называемыми позиционными параметрами.
Приложение присваивает значения параметрам перед выполнением оператора.

Пример обновления учетной записи пользователя с использованием подготовленных операторов:

.. code-block::

	try (PreparedStatement stmt1 = connection.prepareStatement(
			"SELECT userId FROM users WHERE " +
			"lastName = ? AND firstName = ?")) {
	stmt1.setString(1, "Doe");
	stmt1.setString(2, "Joe");
	try (ResultSet rs = stmt1.executeQuery()) {

		if (rs.next()) {
			int userId = rs.getInt(1);

			try (PreparedStatement stmt2 =
					connection.prepareStatement(
						"UPDATE accounts SET accountEnabled = 1 " +
						"WHERE userId = ?" )) {
				stmt2.setInt(1, userId);

				int rowsUpdated = stmt2.executeUpdate();

				if (rowsUpdated == 0) {
					try (PreparedStatement stmt3 =
							connection.prepareStatement(
								"INSERT INTO accounts " +
								"(userId, enabled) VALUES (?, 1)")) {
						stmt3.setInt(1, userId);
						rowsUpdated = stmt3.executeUpdate();
					}
					}
					if (rowsUpdated != 1)
					throw new SomeException(
						"User was not updated correctly.");
				}
			}
		}
	}

Недостатки использования подготовленных операторов:

#. Вместо одного объекта оператора нужно использовать три, по одному на каждый оператор.
#. Перед выполнением оператора нужно задать его параметры. К параметрам обращаются по их позиции.
   Интерфейс ``PreparedStatement`` предоставляет методы настройки для всех типов в ``Java``, а также для некоторых часто используемых типов данных ``SQL`` (``BLOB``, ``CLOB`` и т. д.).
   Значение ``NULL`` устанавливается вызовом метода ``PreparedStatement.setNull(int)``.
#. Необходимо использовать четыре вложенных блока ``try-with-resources``.


Преимуществом такого подхода является, во-первых, защита от ``SQL-инъекций``, поскольку значения передаются отдельно от самого оператора.
Во-вторых, драйвер обрабатывает преобразование типов объектов ``Java`` в правильный формат для целевого типа данных в ``Firebird``,
то есть не нужно преобразовывать значение ``Java`` в правильный формат строкового литерала для диалекта ``SQL`` в ``Firebird``.

Для решения описанных недостатков нужно подготавливать операторы перед их вызовом (например, в конструкторе) и закрывать их при завершении работы приложения.
В этом случае код будет более читаемым, но за управление подготовленными операторами будет отвечать приложение.
При закрытии соединения объект подготовленного оператора будет удален, но приложение об этом не будет знать.
Если приложение использует схожие операторы в разных своих частях, рефакторинг может затронуть множество классов, что, возможно, дестабилизирует код.

Переписанный пример с использованием подготовленных запросов:

.. code-block::

	// prepared statement management
	PreparedStatement queryStmt =
		connection.prepareStatement(queryStr);
	PreparedStatement updateStmt =
		connection.prepareStatement(updateStr);
	PreparedStatement insertStmt =
		connection.prepareStatement(insertStr);

	......................

	// query management
	queryStmt.clearParameters();
	queryStmt.setString(1, "Doe");
	queryStmt.setString(2, "Joe");
	try (ResultSet rs = queryStmt.executeQuery()) {
	if (rs.next()) {
		int userId = rs.getInt(1);

		updateStmt.clearParameters();
		updateStmt.setInt(1, userId);
		int rowsUpdated = updateStmt.executeUpdate();

		if (rowsUpdated == 0) {
		insertStmt.clearParameters();
		insertStmt.setInt(1, userId);
		rowsUpdated = insertStmt.executeUpdate();
		}

		if (rowsUpdated != 1)
		throw new SomeException(
			"User was not updated correctly.");
	}
	}
	......................

	// prepared statement cleanup
	insertStmt.close();
	updateStmt.close();
	queryStmt.close();

Поскольку один и тот же оператор может использоваться для разных значений параметров,
объект соединения имеет возможность выполнять кэширование подготовленного оператора.

Драйвер ``JDBC`` может проигнорировать запрос на закрытие подготовленного оператора, сохранить его и использовать повторно каждый раз,
когда нужно выполнить подготовку ``SQL-оператора``, который уже известен соединению.

Интерфейс java.sql.CallableStatement
-----------------------------------------

Интерфейс ``CallableStatement`` расширяет ``PreparedStatement`` методами для выполнения и получения результатов из хранимых процедур.
Он был введен в спецификацию ``JDBC`` для унификации доступа к хранимым процедурам в различных системах баз данных.
Основное отличие от ``PreparedStatement`` заключается в том, что вызов процедуры задается с помощью переносимого синтаксиса escape.

Унифицированный ``escape-синтаксис`` для выполнения хранимых процедур:

.. code-block:: redstatement

	procedure call ::= {[?=]call <procedure-name>(<params>)}
	params ::= <param> [, <param> ...]

Каждая хранимая процедура может принимать ноль и более входных параметров, подобно интерфейсу ``PreparedStatement``.
После выполнения процедура может либо возвращать данные в выходных параметрах, либо возвращать набор результатов, который можно обработать.

Параметры ``IN`` и ``OUT`` указываются в одном операторе. Приведенный выше синтаксис не позволяет указать тип параметра, поэтому нужно использовать дополнительные инструменты,
чтобы указать, какой параметр будет содержать выходные значения, остальные считаются входными.

Хранимые процедуры
~~~~~~~~~~~~~~~~~~~~~~~

Хранимые процедуры представляют собой код, написанный на языке ``PSQL``,
который позволяет выполнять ``SQL-операторы`` на **собственной скорости движка???** и предоставляет возможности для ограниченного управления потоком выполнения.
``PSQL`` не является языком общего назначения, поэтому его возможности ограничены, когда речь идет о взаимодействии с другими системами.

Хранимые процедуры ``Firebird`` можно классифицировать следующим образом:

* Процедуры, которые не возвращают никаких результатов. Это хранимые процедуры, которые не содержат ключевого слова ``RETURNS`` в заголовке.
* Процедуры, возвращающие только одну строку. Это хранимые процедуры, которые содержат ключевое слово ``RETURNS`` в заголовке, но не содержат ``SUSPEND`` в теле.
  Их можно рассматривать как функции, возвращающие несколько значений. Они выполняются с помощью оператора ``EXECUTE PROCEDURE``.
* Процедуры, возвращающие набор результатов. Процедуры выборки выполняются с помощью ``SQL-оператора`` ``SELECT * FROM myProcedure(...)``.
  Также можно использовать оператор EXECUTE PROCEDURE, но это может привести к странным результатам,
  поскольку это эквивалентно выполнению оператора SELECT, но с выполнением только одной выборки.
  Если нужно извлечь все строки, которые возвращает процедура, то логика будет нарушена.

Пример хранимой процедуры, которая возвращает факториал указанного числа:

.. code-block::

	CREATE PROCEDURE factorial(
		max_value INTEGER
	) RETURNS (
		factorial INTEGER
	) AS
		DECLARE VARIABLE temp INTEGER;
		DECLARE VARIABLE counter INTEGER;
		BEGIN
			counter = 0;
			temp = 1;
		WHILE (counter <= max_value) DO BEGIN
			IF (counter = 0) THEN
				temp = 1;
			ELSE
				temp = temp * counter;
				counter = counter + 1;
		END
		factorial = temp;
	END

Процедуру можно выполнить, вызвав ``EXECUTE PROCEDURE``:

.. code-block::

	EXECUTE PROCEDURE factorial(5);

	FACTORIAL
	============
	120

Преобразованная процедура, возвращающая промежуточные результаты:

.. code-block::

	CREATE PROCEDURE factorial_selectable(
		max_value INTEGER
	) RETURNS (
		row_num INTEGER,
		factorial INTEGER
	) AS
		DECLARE VARIABLE temp INTEGER;
		DECLARE VARIABLE counter INTEGER;
	BEGIN
		counter = 0;
		temp = 1;
		WHILE (counter <= max_value) DO BEGIN
			IF (row_num = 0) THEN
				temp = 1;
			ELSE
				temp = temp * counter;
				factorial = temp;
				row_num = counter;
				counter = counter + 1;
			SUSPEND;
		END
	END

Если создать эту процедуру с помощью ``isql``, а затем выполнить ``SELECT * FROM factorial_selectable(5)``, результат будет следующим:

.. code-block::

	SELECT * FROM factorial_selectable(5);

	ROW_NUM  FACTORIAL
	======== ============
    0        1
    1        1
    2        2
    3        6
    4        24
    5        120

Использование CallableStatement
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``CallableStatement`` позволяет обращаться к процедурам, которые определены выше.

Можно выполнить такую процедуру, используя ``EXECUTE PROCEDURE`` и ``PreparedStatement``, однако такой подход требует дополнительного кода для обработки набора результатов:

.. code-block::

	try (PreparedStatement stmt = connection.prepareStatement(
			"EXECUTE PROCEDURE factorial(?)")) {

		stmt.setInt(1, 2);

		try (ResultSet rs = stmt.executeQuery()) {
			rs.next(); // move cursor to the first row

			int result = rs.getInt(1);
		}
	}

Однако стандартом для вызова хранимых процедур в JDBC является использование ``CallableStatement``.
Вызов может быть определен с помощью ``escaped-синтаксиса``, но также поддерживается синтаксис ``Firebird`` ``EXECUTE PROCEDURE``.

Обращение к исполняемой процедуре через ``CallableStatement``:

.. code-block::

	try (CallableStatement stmt = connection.prepareCall(
			"{call factorial(?,?)}")) {

		stmt.setInt(1, 2);
		stmt.registerOutParameter(2, Types.INTEGER);

		stmt.execute();

		int result = stmt.getInt(2);
	}

В первом примере содержится только входной параметр с позицией 1, а параметр ``OUT`` возвращается в ``ResultSet`` на первую позицию,
поэтому доступ к нему осуществлялся через индекс 1.

Во втором примере присутствует параметр OUT, определённый с помощью CallableStatement.registerOutParameter как выходной параметр типа INTEGER.
Остальные параметры рассматриваются как входные.

Подготовка вызова хранимой процедуры происходит в методе ``CallableStatement.execute``, а не в методе ``prepareCall`` объекта ``Connection``.
Причина такого отклонения от спецификации в том, что ``Firebird`` не позволяет подготовить процедуру без указания параметров.

Допустимо использовать параметр вызова процедуры и как входной, и как выходной параметр.
Это рекомендуется использовать только при переносе приложений с серверов баз данных, которые содержат ``INOUT`` параметры, например ``Oracle``.

Вызов хранимой процедуры с помощью ``CallableStatement`` эквивалентен вызову с помощью подготовленного оператора, как показано в первом примере.
При использовании интерфейса ``CallableStatement`` нет ощутимой разницы в производительности.

Спецификация ``JDBC`` допускает другой синтаксис для вызова хранимой процедуры:

.. code-block::

	try (CallableStatement stmt = connection.prepareCall(
			"{?= call factorial(?}")) {

		stmt.registerOutParameter(1, Types.INTEGER);
		stmt.setInt(2, 2);

		stmt.execute();

		int result = stmt.getInt(1);
	}

Входной параметр теперь имеет индекс 2, а не 1, как в предыдущем примере.
Можно использовать такой синтаксис для хранимых процедур, возвращающих более одного параметра, объединив код из примеров.

Хранимые процедуры также могут возвращать наборы результатов. Это осуществляется с помощью ключевого слова ``SUSPEND`` внутри тела процедуры.
Оно возвращает текущие значения выходных параметров в виде одной строки.

Следующий пример содержит хранимую процедуру, которая вычисляет набор факториалов чисел до указанного количества строк.

``SQL-оператор`` ``SELECT`` - это способ доступа к процедурам с выборкой.
Выборку из таких процедур можно сделать с помощью объектов ``Statement`` или ``PreparedStatement``.

Также можно получить доступ к хранимым процедурам с выборкой через интерфейс ``CallableStatement``.
Вызов должен включать параметры ``IN`` и ``OUT``. После подготовки вызова параметры устанавливаются таким же образом.
Приложение должно явно сообщить драйверу, что используется процедура выбора и требуется доступ к набору результатов.
Это осуществляется вызовом метода, определенного для ``Jaybird``, как показано в примере ниже.
Если этого не сделать, приложение получит доступ только к первой строке набора результатов.

Методы ``get`` из интерфейса ``CallableStatement`` предоставляют вам доступ только к первой строке набора результатов.
Для получения доступа к полному результирующему набору, необходимо использовать либо метод ``executeQuery``, либо метод ``execute``, за которым следует метод ``getResultSet``.

Пример хранимой процедуры выбора с использованием ``escaped-синтаксиса``:

.. code-block::

	import java.sql.*;
	import org.firebirdsql.jdbc.*;
	...
	try (CallableStatement stmt = connection.prepareCall(
			"{call factorial(?, ?, ?)}")) {

		FirebirdCallableStatement fbStmt =
			(FirebirdCallableStatement)stmt;
		fbStmt.setSelectableProcedure(true);

		stmt.setInt(1, 5);
		stmt.registerOutParameter(2, Types.INTEGER); // first OUT
		stmt.registerOutParameter(3, Types.INTEGER); // second OUT

		try (ResultSet rs = stmt.executeQuery()) {

			while(rs.next()) {
			int firstCol = rs.getInt(1);             // first OUT
			int secondCol = rs.getInt(2);            // second OUT
			int anotherSecondCol = stmt.getInt(3);   // second OUT
			}
		}
	}

При обращении через интерфейс ``ResultSet`` позиции выходных параметров (``firstCol`` и ``secondCol`` в примере) нумеруются в порядке их появления в вызове процедуры, начиная с 1.

Если обращение к параметру ``OUT`` осуществляется через интерфейс ``CallableStatement`` (параметр ``anotherSecondCol`` примере), нужно использовать указанные позицию.
Но в этом случае результирующий набор можно использовать только для навигации.

Описание выходных и входных параметров
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Метод ``PreparedStatement.getMetaData`` используется для получения описания столбцов, которые будут возвращены подготовленным оператором ``SELECT``.
Метод возвращает экземпляр интерфейса ``java.sql.ResultSetMetaData``, который предоставляет следующее:

* Тип столбца, название типа, его масштаб и точность;
* Имя столбца, его подпись и его размер для отображения;
* Имя таблицы, которой принадлежит столбец;
* Информацию о том, доступен ли столбец для чтения или для записи, содержит ли он числа со знаком, может ли он содержать значения ``NULL`` и т.д.

В спецификации ``JDBC 3.0`` появился интерфейс ``java.sql.ParameterMetaData``,
который предоставляет аналогичную информацию для входных параметров объектов ``PreparedStatement`` и ``CallableStatement``.

Из-за особенностей реализации ``escaped-синтаксиса`` для вызываемых операторов не допускается
вызов ``getParameterMetaData`` до того, как будут зарегистрированы все ``OUT-параметры``.
В противном случае драйвер попытается подготовить процедуру с неправильным количеством параметров, и сервер базы данных вернёт ошибку.

Пакетные обновления
----------------------

Пакетные обновления предназначены для объединения нескольких операций обновления,
которые должны быть отправлены на сервер базы данных для одновременной обработки.
``Firebird 3.0`` и более ранние версии не поддерживали этот функционал, поэтому ``Jaybird 4`` и более ранние версии эмулируют его, отправляя отдельные команды обновления.

Пакетные обновления с использованием интерфейса java.sql.Statement
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Интерфейс ``Statement`` предоставляет три метода для пакетного обновления: ``addBatch``, ``executeBatch`` и ``clearBatch``.
В пакет допустимо добавлять операторы ``INSERT/UPDATE/DELETE`` или ``DDL``. Добавление оператора, возвращающего результирующий набор, является ошибкой.

Пример пакетного обновления с использованием объекта ``Statement``:

.. code-block::

	try (Statement stmt = connection.createStatement()) {
		stmt.addBatch("UPDATE products " +
			"SET amount = amount - 1 WHERE id = 1");
		stmt.addBatch("INSERT INTO orders(id, amount) VALUES(1, 1)");

		int[] updateCounts = stmt.executeBatch();
	}

Спецификация ``JDBC`` рекомендует отключать режим ``auto-commit``, чтобы обеспечить стандартное поведение для всех баз данных.
В спецификации явно указано, что поведение в режиме ``auto-commit`` зависит от реализации.

В режиме ``auto-commit`` пакет выполняется в одной транзакции, которая фиксируется, если во время выполнения пакета не было исключений,
или откатывается, если хотя бы одна команда привела к ошибке.

Метод ``Statement.executeBatch`` отправляет команду на сервер базы данных.
В случае успешного выполнения всего пакета он возвращает массив целых чисел, содержащий количество обновлений для каждой из команд.
Возможными значениями являются:

* 0 или положительное значение - это количество обновлений для соответствующего оператора.
* ``Statement.SUCCESS_NO_INFO`` - нет информации о количестве обновлений, но оператор был выполнен успешно.

Метод ``Statement.executeBatch`` закрывает текущий результирующий набор, если он открыт. После выполнения пакет очищается.
Вызов ``execute``, ``executeUpdate`` и ``executeQuery`` до выполнения пакета не оказывает влияния на добавленные в пакет операторы.

Если хотя бы один оператор из пакета не выполнится, будет получено исключение ``java.sql.BatchUpdateException``.
``Jaybird`` прекратит выполнение операторов после первой ошибки. В режиме ``auto-commit`` он также откатит транзакцию.
Можно узнать количество обновлений для уже выполненных операторов с помощью метода ``getUpdateCounts`` класса ``BatchUpdateException``.
Возвращаемый массив всегда будет содержать меньше записей, чем было операторов в пакете, так как содержит значения только для выполненных операторов.

Пакетные обновления с помощью java.sql.PreparedStatement и java.sql.CallableStatement
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Использование пакетных обновлений с помощью подготовленного оператора схоже с подходом ``java.sql.Statement``.
Отличие заключается в том, что можно использовать только один оператор, но с разными наборами значений параметров.

Пример пакетного обновления с помощью ``PreparedStatement``:

.. code-block::

	try (PreparedStatement stmt = connection.prepareStatement(
		"INSERT INTO products(id, name) VALUES(?, ?)")) {
		stmt.setInt(1, 1);
		stmt.setString(2, "apple");
		stmt.addBatch();

		stmt.setInt(1, 2);
		stmt.setString(2, "orange");
		stmt.addBatch();

		int[] updateCounts = stmt.executeBatch();
	}

Пример пакетного обновления с помощью ``CallableStatement``:

.. code-block::

	try (CallableStatement stmt = connection.prepareCall(
		"{call add_product(?, ?)")) {
		stmt.setInt(1, 1);
		stmt.setString(2, "apple");
		stmt.addBatch();

		stmt.setInt(1, 2);
		stmt.setString(2, "orange");
		stmt.addBatch();

		int[] updateCounts = stmt.executeBatch();
	}

.. _BATCHUPDATES:

Пакетные обновления на стороне сервера
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В ``Jaybird 5`` добавлена поддержка пакетных обновлений на стороне сервера при работе с ``Firebird 4.0`` или выше.
Но есть ряд ограничений:

* Поддерживается только pure протокол;
* Поддерживается только для ``PreparedStatement``;
* В случае запроса сгенерированных ключей получится поведение эмулирования, поскольку серверные батчи не поддерживают возврат значений, полученных с помощью предложения ``RETURNING``;
* Cерверные пакеты не поддерживают выполнение операторов без параметров;
  В ``Jaybird 5.0.0 - 5.0.4`` это приведёт к ошибке ``Statement used in batch must have parameters (isc_batch_param, 335545186)``.
  Обходным путем является подключение с параметром ``useServerBatch = false``, или не использовать подготовленный оператор;
* В Firebird 4.0 и Ред Базе Данных 5.0 есть возможность отправлять ``BLOB-значения`` в пакетной операции, но это пока не используется в ``Jaybird``.

Escape-синтаксис
--------------------

Escape-синтаксис был введен в качестве поддерживаемого JDBC синтаксиса для обозначения частей языка SQL,
которые реализованы по-разному в разных СУБД.
Этот синтаксис также используется для определения функций, которые не реализованы сервером базы данных, но есть в драйвере.

Спецификация ``JDBC`` определяет ``escaped-синтаксис`` для следующих функций:

* Скалярные функции;
* Литералы даты и времени;
* Внешние соединения;
* Вызов хранимых процедур;
* ``Escape-символы`` для оператора ``LIKE``.

Скалярные функции
~~~~~~~~~~~~~~~~~~~~~

``Escape-синтаксис`` для вызова скалярной функции:

.. code-block:: redstatement

	{fn <имя функции> (список аргументов)}

Например, ``{fn concat('Firebird', 'Java')}`` в результате будет отправлено на сервер как ``('Firebird'|||'Java')``.

Литералы даты и времени
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Спецификация ``JDBC`` предусматривает  ``escape-синтаксис`` для использования литералов даты и времени в операторе.

Литералы даты:

.. code-block:: redstatement

	{d 'yyyy-mm-dd'}

Литералы времени:

.. code-block:: redstatement

	{t 'hh:mm:ss'}

Литерал временной метки ( дробная часть секунд ``'.f...'`` может быть опущена):

.. code-block:: redstatement

	{ts 'yyyy-mm-dd hh:mm:ss.f...'}

Внещние соединения
~~~~~~~~~~~~~~~~~~~~~~

``Escape-синтаксис`` для внешних соединений:

.. code-block::

	{oj <соединение>}

	<соединение> ::=
    	<таблица> {LEFT|RIGHT|FULL} OUTER JOIN
    	{<таблица> | <соединение>} ON <условие соединения>

Пример ``SQL-оператора``:

.. code-block::

	SELECT * FROM {oj tableA a
		LEFT OUTER JOIN tableB b ON a.id = b.id}

Хранимые процедуры
~~~~~~~~~~~~~~~~~~~~~~~~~

``Escape-синтаксис`` хранимых процедур подробно описан в разделе `Интерфейс java.sql.CallableStatement`_.

Оператор LIKE
~~~~~~~~~~~~~~~~~~

Знак процента (``'%'``) и символ подчеркивания (``'_'``), нужно экранировать символом обратной косой черты (``'\'``), чтобы интерпретировать их буквально, как обычный
символ, присутствующий в строке.

В этом случае ``escape-синтаксис`` определяет, какой символ будет рассматриваться, как экранирующий:

.. code-block:: redstatement

	{escape '<экранирующий символ>'}







